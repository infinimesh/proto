// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: node/node.proto

package nodeconnect

import (
	context "context"
	errors "errors"
	connect_go "github.com/bufbuild/connect-go"
	node "github.com/infinimesh/proto/node"
	access "github.com/infinimesh/proto/node/access"
	accounts "github.com/infinimesh/proto/node/accounts"
	devices "github.com/infinimesh/proto/node/devices"
	namespaces "github.com/infinimesh/proto/node/namespaces"
	shadow "github.com/infinimesh/proto/shadow"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect_go.IsAtLeastVersion0_1_0

const (
	// AccountsServiceName is the fully-qualified name of the AccountsService service.
	AccountsServiceName = "infinimesh.node.AccountsService"
	// NamespacesServiceName is the fully-qualified name of the NamespacesService service.
	NamespacesServiceName = "infinimesh.node.NamespacesService"
	// DevicesServiceName is the fully-qualified name of the DevicesService service.
	DevicesServiceName = "infinimesh.node.DevicesService"
	// ShadowServiceName is the fully-qualified name of the ShadowService service.
	ShadowServiceName = "infinimesh.node.ShadowService"
	// InternalServiceName is the fully-qualified name of the InternalService service.
	InternalServiceName = "infinimesh.node.InternalService"
)

// AccountsServiceClient is a client for the infinimesh.node.AccountsService service.
type AccountsServiceClient interface {
	Token(context.Context, *connect_go.Request[node.TokenRequest]) (*connect_go.Response[node.TokenResponse], error)
	Get(context.Context, *connect_go.Request[accounts.Account]) (*connect_go.Response[accounts.Account], error)
	List(context.Context, *connect_go.Request[node.EmptyMessage]) (*connect_go.Response[accounts.Accounts], error)
	Create(context.Context, *connect_go.Request[accounts.CreateRequest]) (*connect_go.Response[accounts.CreateResponse], error)
	Update(context.Context, *connect_go.Request[accounts.Account]) (*connect_go.Response[accounts.Account], error)
	Toggle(context.Context, *connect_go.Request[accounts.Account]) (*connect_go.Response[accounts.Account], error)
	Delete(context.Context, *connect_go.Request[accounts.Account]) (*connect_go.Response[node.DeleteResponse], error)
	Accessibles(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[access.Nodes], error)
	Deletables(context.Context, *connect_go.Request[accounts.Account]) (*connect_go.Response[access.Nodes], error)
	Move(context.Context, *connect_go.Request[node.MoveRequest]) (*connect_go.Response[node.EmptyMessage], error)
	GetCredentials(context.Context, *connect_go.Request[node.GetCredentialsRequest]) (*connect_go.Response[node.GetCredentialsResponse], error)
	SetCredentials(context.Context, *connect_go.Request[node.SetCredentialsRequest]) (*connect_go.Response[node.SetCredentialsResponse], error)
	DelCredentials(context.Context, *connect_go.Request[node.DeleteCredentialsRequest]) (*connect_go.Response[node.DeleteResponse], error)
}

// NewAccountsServiceClient constructs a client for the infinimesh.node.AccountsService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewAccountsServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) AccountsServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &accountsServiceClient{
		token: connect_go.NewClient[node.TokenRequest, node.TokenResponse](
			httpClient,
			baseURL+"/infinimesh.node.AccountsService/Token",
			opts...,
		),
		get: connect_go.NewClient[accounts.Account, accounts.Account](
			httpClient,
			baseURL+"/infinimesh.node.AccountsService/Get",
			opts...,
		),
		list: connect_go.NewClient[node.EmptyMessage, accounts.Accounts](
			httpClient,
			baseURL+"/infinimesh.node.AccountsService/List",
			opts...,
		),
		create: connect_go.NewClient[accounts.CreateRequest, accounts.CreateResponse](
			httpClient,
			baseURL+"/infinimesh.node.AccountsService/Create",
			opts...,
		),
		update: connect_go.NewClient[accounts.Account, accounts.Account](
			httpClient,
			baseURL+"/infinimesh.node.AccountsService/Update",
			opts...,
		),
		toggle: connect_go.NewClient[accounts.Account, accounts.Account](
			httpClient,
			baseURL+"/infinimesh.node.AccountsService/Toggle",
			opts...,
		),
		delete: connect_go.NewClient[accounts.Account, node.DeleteResponse](
			httpClient,
			baseURL+"/infinimesh.node.AccountsService/Delete",
			opts...,
		),
		accessibles: connect_go.NewClient[namespaces.Namespace, access.Nodes](
			httpClient,
			baseURL+"/infinimesh.node.AccountsService/Accessibles",
			opts...,
		),
		deletables: connect_go.NewClient[accounts.Account, access.Nodes](
			httpClient,
			baseURL+"/infinimesh.node.AccountsService/Deletables",
			opts...,
		),
		move: connect_go.NewClient[node.MoveRequest, node.EmptyMessage](
			httpClient,
			baseURL+"/infinimesh.node.AccountsService/Move",
			opts...,
		),
		getCredentials: connect_go.NewClient[node.GetCredentialsRequest, node.GetCredentialsResponse](
			httpClient,
			baseURL+"/infinimesh.node.AccountsService/GetCredentials",
			opts...,
		),
		setCredentials: connect_go.NewClient[node.SetCredentialsRequest, node.SetCredentialsResponse](
			httpClient,
			baseURL+"/infinimesh.node.AccountsService/SetCredentials",
			opts...,
		),
		delCredentials: connect_go.NewClient[node.DeleteCredentialsRequest, node.DeleteResponse](
			httpClient,
			baseURL+"/infinimesh.node.AccountsService/DelCredentials",
			opts...,
		),
	}
}

// accountsServiceClient implements AccountsServiceClient.
type accountsServiceClient struct {
	token          *connect_go.Client[node.TokenRequest, node.TokenResponse]
	get            *connect_go.Client[accounts.Account, accounts.Account]
	list           *connect_go.Client[node.EmptyMessage, accounts.Accounts]
	create         *connect_go.Client[accounts.CreateRequest, accounts.CreateResponse]
	update         *connect_go.Client[accounts.Account, accounts.Account]
	toggle         *connect_go.Client[accounts.Account, accounts.Account]
	delete         *connect_go.Client[accounts.Account, node.DeleteResponse]
	accessibles    *connect_go.Client[namespaces.Namespace, access.Nodes]
	deletables     *connect_go.Client[accounts.Account, access.Nodes]
	move           *connect_go.Client[node.MoveRequest, node.EmptyMessage]
	getCredentials *connect_go.Client[node.GetCredentialsRequest, node.GetCredentialsResponse]
	setCredentials *connect_go.Client[node.SetCredentialsRequest, node.SetCredentialsResponse]
	delCredentials *connect_go.Client[node.DeleteCredentialsRequest, node.DeleteResponse]
}

// Token calls infinimesh.node.AccountsService.Token.
func (c *accountsServiceClient) Token(ctx context.Context, req *connect_go.Request[node.TokenRequest]) (*connect_go.Response[node.TokenResponse], error) {
	return c.token.CallUnary(ctx, req)
}

// Get calls infinimesh.node.AccountsService.Get.
func (c *accountsServiceClient) Get(ctx context.Context, req *connect_go.Request[accounts.Account]) (*connect_go.Response[accounts.Account], error) {
	return c.get.CallUnary(ctx, req)
}

// List calls infinimesh.node.AccountsService.List.
func (c *accountsServiceClient) List(ctx context.Context, req *connect_go.Request[node.EmptyMessage]) (*connect_go.Response[accounts.Accounts], error) {
	return c.list.CallUnary(ctx, req)
}

// Create calls infinimesh.node.AccountsService.Create.
func (c *accountsServiceClient) Create(ctx context.Context, req *connect_go.Request[accounts.CreateRequest]) (*connect_go.Response[accounts.CreateResponse], error) {
	return c.create.CallUnary(ctx, req)
}

// Update calls infinimesh.node.AccountsService.Update.
func (c *accountsServiceClient) Update(ctx context.Context, req *connect_go.Request[accounts.Account]) (*connect_go.Response[accounts.Account], error) {
	return c.update.CallUnary(ctx, req)
}

// Toggle calls infinimesh.node.AccountsService.Toggle.
func (c *accountsServiceClient) Toggle(ctx context.Context, req *connect_go.Request[accounts.Account]) (*connect_go.Response[accounts.Account], error) {
	return c.toggle.CallUnary(ctx, req)
}

// Delete calls infinimesh.node.AccountsService.Delete.
func (c *accountsServiceClient) Delete(ctx context.Context, req *connect_go.Request[accounts.Account]) (*connect_go.Response[node.DeleteResponse], error) {
	return c.delete.CallUnary(ctx, req)
}

// Accessibles calls infinimesh.node.AccountsService.Accessibles.
func (c *accountsServiceClient) Accessibles(ctx context.Context, req *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[access.Nodes], error) {
	return c.accessibles.CallUnary(ctx, req)
}

// Deletables calls infinimesh.node.AccountsService.Deletables.
func (c *accountsServiceClient) Deletables(ctx context.Context, req *connect_go.Request[accounts.Account]) (*connect_go.Response[access.Nodes], error) {
	return c.deletables.CallUnary(ctx, req)
}

// Move calls infinimesh.node.AccountsService.Move.
func (c *accountsServiceClient) Move(ctx context.Context, req *connect_go.Request[node.MoveRequest]) (*connect_go.Response[node.EmptyMessage], error) {
	return c.move.CallUnary(ctx, req)
}

// GetCredentials calls infinimesh.node.AccountsService.GetCredentials.
func (c *accountsServiceClient) GetCredentials(ctx context.Context, req *connect_go.Request[node.GetCredentialsRequest]) (*connect_go.Response[node.GetCredentialsResponse], error) {
	return c.getCredentials.CallUnary(ctx, req)
}

// SetCredentials calls infinimesh.node.AccountsService.SetCredentials.
func (c *accountsServiceClient) SetCredentials(ctx context.Context, req *connect_go.Request[node.SetCredentialsRequest]) (*connect_go.Response[node.SetCredentialsResponse], error) {
	return c.setCredentials.CallUnary(ctx, req)
}

// DelCredentials calls infinimesh.node.AccountsService.DelCredentials.
func (c *accountsServiceClient) DelCredentials(ctx context.Context, req *connect_go.Request[node.DeleteCredentialsRequest]) (*connect_go.Response[node.DeleteResponse], error) {
	return c.delCredentials.CallUnary(ctx, req)
}

// AccountsServiceHandler is an implementation of the infinimesh.node.AccountsService service.
type AccountsServiceHandler interface {
	Token(context.Context, *connect_go.Request[node.TokenRequest]) (*connect_go.Response[node.TokenResponse], error)
	Get(context.Context, *connect_go.Request[accounts.Account]) (*connect_go.Response[accounts.Account], error)
	List(context.Context, *connect_go.Request[node.EmptyMessage]) (*connect_go.Response[accounts.Accounts], error)
	Create(context.Context, *connect_go.Request[accounts.CreateRequest]) (*connect_go.Response[accounts.CreateResponse], error)
	Update(context.Context, *connect_go.Request[accounts.Account]) (*connect_go.Response[accounts.Account], error)
	Toggle(context.Context, *connect_go.Request[accounts.Account]) (*connect_go.Response[accounts.Account], error)
	Delete(context.Context, *connect_go.Request[accounts.Account]) (*connect_go.Response[node.DeleteResponse], error)
	Accessibles(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[access.Nodes], error)
	Deletables(context.Context, *connect_go.Request[accounts.Account]) (*connect_go.Response[access.Nodes], error)
	Move(context.Context, *connect_go.Request[node.MoveRequest]) (*connect_go.Response[node.EmptyMessage], error)
	GetCredentials(context.Context, *connect_go.Request[node.GetCredentialsRequest]) (*connect_go.Response[node.GetCredentialsResponse], error)
	SetCredentials(context.Context, *connect_go.Request[node.SetCredentialsRequest]) (*connect_go.Response[node.SetCredentialsResponse], error)
	DelCredentials(context.Context, *connect_go.Request[node.DeleteCredentialsRequest]) (*connect_go.Response[node.DeleteResponse], error)
}

// NewAccountsServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewAccountsServiceHandler(svc AccountsServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/infinimesh.node.AccountsService/Token", connect_go.NewUnaryHandler(
		"/infinimesh.node.AccountsService/Token",
		svc.Token,
		opts...,
	))
	mux.Handle("/infinimesh.node.AccountsService/Get", connect_go.NewUnaryHandler(
		"/infinimesh.node.AccountsService/Get",
		svc.Get,
		opts...,
	))
	mux.Handle("/infinimesh.node.AccountsService/List", connect_go.NewUnaryHandler(
		"/infinimesh.node.AccountsService/List",
		svc.List,
		opts...,
	))
	mux.Handle("/infinimesh.node.AccountsService/Create", connect_go.NewUnaryHandler(
		"/infinimesh.node.AccountsService/Create",
		svc.Create,
		opts...,
	))
	mux.Handle("/infinimesh.node.AccountsService/Update", connect_go.NewUnaryHandler(
		"/infinimesh.node.AccountsService/Update",
		svc.Update,
		opts...,
	))
	mux.Handle("/infinimesh.node.AccountsService/Toggle", connect_go.NewUnaryHandler(
		"/infinimesh.node.AccountsService/Toggle",
		svc.Toggle,
		opts...,
	))
	mux.Handle("/infinimesh.node.AccountsService/Delete", connect_go.NewUnaryHandler(
		"/infinimesh.node.AccountsService/Delete",
		svc.Delete,
		opts...,
	))
	mux.Handle("/infinimesh.node.AccountsService/Accessibles", connect_go.NewUnaryHandler(
		"/infinimesh.node.AccountsService/Accessibles",
		svc.Accessibles,
		opts...,
	))
	mux.Handle("/infinimesh.node.AccountsService/Deletables", connect_go.NewUnaryHandler(
		"/infinimesh.node.AccountsService/Deletables",
		svc.Deletables,
		opts...,
	))
	mux.Handle("/infinimesh.node.AccountsService/Move", connect_go.NewUnaryHandler(
		"/infinimesh.node.AccountsService/Move",
		svc.Move,
		opts...,
	))
	mux.Handle("/infinimesh.node.AccountsService/GetCredentials", connect_go.NewUnaryHandler(
		"/infinimesh.node.AccountsService/GetCredentials",
		svc.GetCredentials,
		opts...,
	))
	mux.Handle("/infinimesh.node.AccountsService/SetCredentials", connect_go.NewUnaryHandler(
		"/infinimesh.node.AccountsService/SetCredentials",
		svc.SetCredentials,
		opts...,
	))
	mux.Handle("/infinimesh.node.AccountsService/DelCredentials", connect_go.NewUnaryHandler(
		"/infinimesh.node.AccountsService/DelCredentials",
		svc.DelCredentials,
		opts...,
	))
	return "/infinimesh.node.AccountsService/", mux
}

// UnimplementedAccountsServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedAccountsServiceHandler struct{}

func (UnimplementedAccountsServiceHandler) Token(context.Context, *connect_go.Request[node.TokenRequest]) (*connect_go.Response[node.TokenResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.Token is not implemented"))
}

func (UnimplementedAccountsServiceHandler) Get(context.Context, *connect_go.Request[accounts.Account]) (*connect_go.Response[accounts.Account], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.Get is not implemented"))
}

func (UnimplementedAccountsServiceHandler) List(context.Context, *connect_go.Request[node.EmptyMessage]) (*connect_go.Response[accounts.Accounts], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.List is not implemented"))
}

func (UnimplementedAccountsServiceHandler) Create(context.Context, *connect_go.Request[accounts.CreateRequest]) (*connect_go.Response[accounts.CreateResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.Create is not implemented"))
}

func (UnimplementedAccountsServiceHandler) Update(context.Context, *connect_go.Request[accounts.Account]) (*connect_go.Response[accounts.Account], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.Update is not implemented"))
}

func (UnimplementedAccountsServiceHandler) Toggle(context.Context, *connect_go.Request[accounts.Account]) (*connect_go.Response[accounts.Account], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.Toggle is not implemented"))
}

func (UnimplementedAccountsServiceHandler) Delete(context.Context, *connect_go.Request[accounts.Account]) (*connect_go.Response[node.DeleteResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.Delete is not implemented"))
}

func (UnimplementedAccountsServiceHandler) Accessibles(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[access.Nodes], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.Accessibles is not implemented"))
}

func (UnimplementedAccountsServiceHandler) Deletables(context.Context, *connect_go.Request[accounts.Account]) (*connect_go.Response[access.Nodes], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.Deletables is not implemented"))
}

func (UnimplementedAccountsServiceHandler) Move(context.Context, *connect_go.Request[node.MoveRequest]) (*connect_go.Response[node.EmptyMessage], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.Move is not implemented"))
}

func (UnimplementedAccountsServiceHandler) GetCredentials(context.Context, *connect_go.Request[node.GetCredentialsRequest]) (*connect_go.Response[node.GetCredentialsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.GetCredentials is not implemented"))
}

func (UnimplementedAccountsServiceHandler) SetCredentials(context.Context, *connect_go.Request[node.SetCredentialsRequest]) (*connect_go.Response[node.SetCredentialsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.SetCredentials is not implemented"))
}

func (UnimplementedAccountsServiceHandler) DelCredentials(context.Context, *connect_go.Request[node.DeleteCredentialsRequest]) (*connect_go.Response[node.DeleteResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.DelCredentials is not implemented"))
}

// NamespacesServiceClient is a client for the infinimesh.node.NamespacesService service.
type NamespacesServiceClient interface {
	Get(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[namespaces.Namespace], error)
	List(context.Context, *connect_go.Request[node.EmptyMessage]) (*connect_go.Response[namespaces.Namespaces], error)
	Create(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[namespaces.Namespace], error)
	Update(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[namespaces.Namespace], error)
	Delete(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[node.DeleteResponse], error)
	Accessibles(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[access.Nodes], error)
	Deletables(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[access.Nodes], error)
	// Accounts having access to this namespace
	Joins(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[accounts.Accounts], error)
	// Sets Access to this namespace for the given account(deletes if level is set
	// to NONE(0))
	Join(context.Context, *connect_go.Request[node.JoinRequest]) (*connect_go.Response[accounts.Accounts], error)
}

// NewNamespacesServiceClient constructs a client for the infinimesh.node.NamespacesService service.
// By default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped
// responses, and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewNamespacesServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) NamespacesServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &namespacesServiceClient{
		get: connect_go.NewClient[namespaces.Namespace, namespaces.Namespace](
			httpClient,
			baseURL+"/infinimesh.node.NamespacesService/Get",
			opts...,
		),
		list: connect_go.NewClient[node.EmptyMessage, namespaces.Namespaces](
			httpClient,
			baseURL+"/infinimesh.node.NamespacesService/List",
			opts...,
		),
		create: connect_go.NewClient[namespaces.Namespace, namespaces.Namespace](
			httpClient,
			baseURL+"/infinimesh.node.NamespacesService/Create",
			opts...,
		),
		update: connect_go.NewClient[namespaces.Namespace, namespaces.Namespace](
			httpClient,
			baseURL+"/infinimesh.node.NamespacesService/Update",
			opts...,
		),
		delete: connect_go.NewClient[namespaces.Namespace, node.DeleteResponse](
			httpClient,
			baseURL+"/infinimesh.node.NamespacesService/Delete",
			opts...,
		),
		accessibles: connect_go.NewClient[namespaces.Namespace, access.Nodes](
			httpClient,
			baseURL+"/infinimesh.node.NamespacesService/Accessibles",
			opts...,
		),
		deletables: connect_go.NewClient[namespaces.Namespace, access.Nodes](
			httpClient,
			baseURL+"/infinimesh.node.NamespacesService/Deletables",
			opts...,
		),
		joins: connect_go.NewClient[namespaces.Namespace, accounts.Accounts](
			httpClient,
			baseURL+"/infinimesh.node.NamespacesService/Joins",
			opts...,
		),
		join: connect_go.NewClient[node.JoinRequest, accounts.Accounts](
			httpClient,
			baseURL+"/infinimesh.node.NamespacesService/Join",
			opts...,
		),
	}
}

// namespacesServiceClient implements NamespacesServiceClient.
type namespacesServiceClient struct {
	get         *connect_go.Client[namespaces.Namespace, namespaces.Namespace]
	list        *connect_go.Client[node.EmptyMessage, namespaces.Namespaces]
	create      *connect_go.Client[namespaces.Namespace, namespaces.Namespace]
	update      *connect_go.Client[namespaces.Namespace, namespaces.Namespace]
	delete      *connect_go.Client[namespaces.Namespace, node.DeleteResponse]
	accessibles *connect_go.Client[namespaces.Namespace, access.Nodes]
	deletables  *connect_go.Client[namespaces.Namespace, access.Nodes]
	joins       *connect_go.Client[namespaces.Namespace, accounts.Accounts]
	join        *connect_go.Client[node.JoinRequest, accounts.Accounts]
}

// Get calls infinimesh.node.NamespacesService.Get.
func (c *namespacesServiceClient) Get(ctx context.Context, req *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[namespaces.Namespace], error) {
	return c.get.CallUnary(ctx, req)
}

// List calls infinimesh.node.NamespacesService.List.
func (c *namespacesServiceClient) List(ctx context.Context, req *connect_go.Request[node.EmptyMessage]) (*connect_go.Response[namespaces.Namespaces], error) {
	return c.list.CallUnary(ctx, req)
}

// Create calls infinimesh.node.NamespacesService.Create.
func (c *namespacesServiceClient) Create(ctx context.Context, req *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[namespaces.Namespace], error) {
	return c.create.CallUnary(ctx, req)
}

// Update calls infinimesh.node.NamespacesService.Update.
func (c *namespacesServiceClient) Update(ctx context.Context, req *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[namespaces.Namespace], error) {
	return c.update.CallUnary(ctx, req)
}

// Delete calls infinimesh.node.NamespacesService.Delete.
func (c *namespacesServiceClient) Delete(ctx context.Context, req *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[node.DeleteResponse], error) {
	return c.delete.CallUnary(ctx, req)
}

// Accessibles calls infinimesh.node.NamespacesService.Accessibles.
func (c *namespacesServiceClient) Accessibles(ctx context.Context, req *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[access.Nodes], error) {
	return c.accessibles.CallUnary(ctx, req)
}

// Deletables calls infinimesh.node.NamespacesService.Deletables.
func (c *namespacesServiceClient) Deletables(ctx context.Context, req *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[access.Nodes], error) {
	return c.deletables.CallUnary(ctx, req)
}

// Joins calls infinimesh.node.NamespacesService.Joins.
func (c *namespacesServiceClient) Joins(ctx context.Context, req *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[accounts.Accounts], error) {
	return c.joins.CallUnary(ctx, req)
}

// Join calls infinimesh.node.NamespacesService.Join.
func (c *namespacesServiceClient) Join(ctx context.Context, req *connect_go.Request[node.JoinRequest]) (*connect_go.Response[accounts.Accounts], error) {
	return c.join.CallUnary(ctx, req)
}

// NamespacesServiceHandler is an implementation of the infinimesh.node.NamespacesService service.
type NamespacesServiceHandler interface {
	Get(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[namespaces.Namespace], error)
	List(context.Context, *connect_go.Request[node.EmptyMessage]) (*connect_go.Response[namespaces.Namespaces], error)
	Create(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[namespaces.Namespace], error)
	Update(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[namespaces.Namespace], error)
	Delete(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[node.DeleteResponse], error)
	Accessibles(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[access.Nodes], error)
	Deletables(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[access.Nodes], error)
	// Accounts having access to this namespace
	Joins(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[accounts.Accounts], error)
	// Sets Access to this namespace for the given account(deletes if level is set
	// to NONE(0))
	Join(context.Context, *connect_go.Request[node.JoinRequest]) (*connect_go.Response[accounts.Accounts], error)
}

// NewNamespacesServiceHandler builds an HTTP handler from the service implementation. It returns
// the path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewNamespacesServiceHandler(svc NamespacesServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/infinimesh.node.NamespacesService/Get", connect_go.NewUnaryHandler(
		"/infinimesh.node.NamespacesService/Get",
		svc.Get,
		opts...,
	))
	mux.Handle("/infinimesh.node.NamespacesService/List", connect_go.NewUnaryHandler(
		"/infinimesh.node.NamespacesService/List",
		svc.List,
		opts...,
	))
	mux.Handle("/infinimesh.node.NamespacesService/Create", connect_go.NewUnaryHandler(
		"/infinimesh.node.NamespacesService/Create",
		svc.Create,
		opts...,
	))
	mux.Handle("/infinimesh.node.NamespacesService/Update", connect_go.NewUnaryHandler(
		"/infinimesh.node.NamespacesService/Update",
		svc.Update,
		opts...,
	))
	mux.Handle("/infinimesh.node.NamespacesService/Delete", connect_go.NewUnaryHandler(
		"/infinimesh.node.NamespacesService/Delete",
		svc.Delete,
		opts...,
	))
	mux.Handle("/infinimesh.node.NamespacesService/Accessibles", connect_go.NewUnaryHandler(
		"/infinimesh.node.NamespacesService/Accessibles",
		svc.Accessibles,
		opts...,
	))
	mux.Handle("/infinimesh.node.NamespacesService/Deletables", connect_go.NewUnaryHandler(
		"/infinimesh.node.NamespacesService/Deletables",
		svc.Deletables,
		opts...,
	))
	mux.Handle("/infinimesh.node.NamespacesService/Joins", connect_go.NewUnaryHandler(
		"/infinimesh.node.NamespacesService/Joins",
		svc.Joins,
		opts...,
	))
	mux.Handle("/infinimesh.node.NamespacesService/Join", connect_go.NewUnaryHandler(
		"/infinimesh.node.NamespacesService/Join",
		svc.Join,
		opts...,
	))
	return "/infinimesh.node.NamespacesService/", mux
}

// UnimplementedNamespacesServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedNamespacesServiceHandler struct{}

func (UnimplementedNamespacesServiceHandler) Get(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[namespaces.Namespace], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.NamespacesService.Get is not implemented"))
}

func (UnimplementedNamespacesServiceHandler) List(context.Context, *connect_go.Request[node.EmptyMessage]) (*connect_go.Response[namespaces.Namespaces], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.NamespacesService.List is not implemented"))
}

func (UnimplementedNamespacesServiceHandler) Create(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[namespaces.Namespace], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.NamespacesService.Create is not implemented"))
}

func (UnimplementedNamespacesServiceHandler) Update(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[namespaces.Namespace], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.NamespacesService.Update is not implemented"))
}

func (UnimplementedNamespacesServiceHandler) Delete(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[node.DeleteResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.NamespacesService.Delete is not implemented"))
}

func (UnimplementedNamespacesServiceHandler) Accessibles(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[access.Nodes], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.NamespacesService.Accessibles is not implemented"))
}

func (UnimplementedNamespacesServiceHandler) Deletables(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[access.Nodes], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.NamespacesService.Deletables is not implemented"))
}

func (UnimplementedNamespacesServiceHandler) Joins(context.Context, *connect_go.Request[namespaces.Namespace]) (*connect_go.Response[accounts.Accounts], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.NamespacesService.Joins is not implemented"))
}

func (UnimplementedNamespacesServiceHandler) Join(context.Context, *connect_go.Request[node.JoinRequest]) (*connect_go.Response[accounts.Accounts], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.NamespacesService.Join is not implemented"))
}

// DevicesServiceClient is a client for the infinimesh.node.DevicesService service.
type DevicesServiceClient interface {
	Get(context.Context, *connect_go.Request[devices.Device]) (*connect_go.Response[devices.Device], error)
	List(context.Context, *connect_go.Request[node.EmptyMessage]) (*connect_go.Response[devices.Devices], error)
	Create(context.Context, *connect_go.Request[devices.CreateRequest]) (*connect_go.Response[devices.CreateResponse], error)
	Update(context.Context, *connect_go.Request[devices.Device]) (*connect_go.Response[devices.Device], error)
	Delete(context.Context, *connect_go.Request[devices.Device]) (*connect_go.Response[node.DeleteResponse], error)
	Toggle(context.Context, *connect_go.Request[devices.Device]) (*connect_go.Response[devices.Device], error)
	ToggleBasic(context.Context, *connect_go.Request[devices.Device]) (*connect_go.Response[devices.Device], error)
	MakeDevicesToken(context.Context, *connect_go.Request[node.DevicesTokenRequest]) (*connect_go.Response[node.TokenResponse], error)
	// Moves Device between Namespaces
	Move(context.Context, *connect_go.Request[node.MoveRequest]) (*connect_go.Response[node.EmptyMessage], error)
	// Accounts and Namesapces having access to this Device
	Joins(context.Context, *connect_go.Request[devices.Device]) (*connect_go.Response[access.Nodes], error)
	// Sets Access to this namespace for the given Node(Account or Namespace) (deletes if level is set
	// to NONE(0))
	// Node is interpret as a Device (uuid is enough) and Join as an Account or Namespace (must be provided fully)
	Join(context.Context, *connect_go.Request[node.JoinGeneralRequest]) (*connect_go.Response[access.Node], error)
	GetByToken(context.Context, *connect_go.Request[devices.Device]) (*connect_go.Response[devices.Device], error)
	GetByFingerprint(context.Context, *connect_go.Request[devices.GetByFingerprintRequest]) (*connect_go.Response[devices.Device], error)
}

// NewDevicesServiceClient constructs a client for the infinimesh.node.DevicesService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewDevicesServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) DevicesServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &devicesServiceClient{
		get: connect_go.NewClient[devices.Device, devices.Device](
			httpClient,
			baseURL+"/infinimesh.node.DevicesService/Get",
			opts...,
		),
		list: connect_go.NewClient[node.EmptyMessage, devices.Devices](
			httpClient,
			baseURL+"/infinimesh.node.DevicesService/List",
			opts...,
		),
		create: connect_go.NewClient[devices.CreateRequest, devices.CreateResponse](
			httpClient,
			baseURL+"/infinimesh.node.DevicesService/Create",
			opts...,
		),
		update: connect_go.NewClient[devices.Device, devices.Device](
			httpClient,
			baseURL+"/infinimesh.node.DevicesService/Update",
			opts...,
		),
		delete: connect_go.NewClient[devices.Device, node.DeleteResponse](
			httpClient,
			baseURL+"/infinimesh.node.DevicesService/Delete",
			opts...,
		),
		toggle: connect_go.NewClient[devices.Device, devices.Device](
			httpClient,
			baseURL+"/infinimesh.node.DevicesService/Toggle",
			opts...,
		),
		toggleBasic: connect_go.NewClient[devices.Device, devices.Device](
			httpClient,
			baseURL+"/infinimesh.node.DevicesService/ToggleBasic",
			opts...,
		),
		makeDevicesToken: connect_go.NewClient[node.DevicesTokenRequest, node.TokenResponse](
			httpClient,
			baseURL+"/infinimesh.node.DevicesService/MakeDevicesToken",
			opts...,
		),
		move: connect_go.NewClient[node.MoveRequest, node.EmptyMessage](
			httpClient,
			baseURL+"/infinimesh.node.DevicesService/Move",
			opts...,
		),
		joins: connect_go.NewClient[devices.Device, access.Nodes](
			httpClient,
			baseURL+"/infinimesh.node.DevicesService/Joins",
			opts...,
		),
		join: connect_go.NewClient[node.JoinGeneralRequest, access.Node](
			httpClient,
			baseURL+"/infinimesh.node.DevicesService/Join",
			opts...,
		),
		getByToken: connect_go.NewClient[devices.Device, devices.Device](
			httpClient,
			baseURL+"/infinimesh.node.DevicesService/GetByToken",
			opts...,
		),
		getByFingerprint: connect_go.NewClient[devices.GetByFingerprintRequest, devices.Device](
			httpClient,
			baseURL+"/infinimesh.node.DevicesService/GetByFingerprint",
			opts...,
		),
	}
}

// devicesServiceClient implements DevicesServiceClient.
type devicesServiceClient struct {
	get              *connect_go.Client[devices.Device, devices.Device]
	list             *connect_go.Client[node.EmptyMessage, devices.Devices]
	create           *connect_go.Client[devices.CreateRequest, devices.CreateResponse]
	update           *connect_go.Client[devices.Device, devices.Device]
	delete           *connect_go.Client[devices.Device, node.DeleteResponse]
	toggle           *connect_go.Client[devices.Device, devices.Device]
	toggleBasic      *connect_go.Client[devices.Device, devices.Device]
	makeDevicesToken *connect_go.Client[node.DevicesTokenRequest, node.TokenResponse]
	move             *connect_go.Client[node.MoveRequest, node.EmptyMessage]
	joins            *connect_go.Client[devices.Device, access.Nodes]
	join             *connect_go.Client[node.JoinGeneralRequest, access.Node]
	getByToken       *connect_go.Client[devices.Device, devices.Device]
	getByFingerprint *connect_go.Client[devices.GetByFingerprintRequest, devices.Device]
}

// Get calls infinimesh.node.DevicesService.Get.
func (c *devicesServiceClient) Get(ctx context.Context, req *connect_go.Request[devices.Device]) (*connect_go.Response[devices.Device], error) {
	return c.get.CallUnary(ctx, req)
}

// List calls infinimesh.node.DevicesService.List.
func (c *devicesServiceClient) List(ctx context.Context, req *connect_go.Request[node.EmptyMessage]) (*connect_go.Response[devices.Devices], error) {
	return c.list.CallUnary(ctx, req)
}

// Create calls infinimesh.node.DevicesService.Create.
func (c *devicesServiceClient) Create(ctx context.Context, req *connect_go.Request[devices.CreateRequest]) (*connect_go.Response[devices.CreateResponse], error) {
	return c.create.CallUnary(ctx, req)
}

// Update calls infinimesh.node.DevicesService.Update.
func (c *devicesServiceClient) Update(ctx context.Context, req *connect_go.Request[devices.Device]) (*connect_go.Response[devices.Device], error) {
	return c.update.CallUnary(ctx, req)
}

// Delete calls infinimesh.node.DevicesService.Delete.
func (c *devicesServiceClient) Delete(ctx context.Context, req *connect_go.Request[devices.Device]) (*connect_go.Response[node.DeleteResponse], error) {
	return c.delete.CallUnary(ctx, req)
}

// Toggle calls infinimesh.node.DevicesService.Toggle.
func (c *devicesServiceClient) Toggle(ctx context.Context, req *connect_go.Request[devices.Device]) (*connect_go.Response[devices.Device], error) {
	return c.toggle.CallUnary(ctx, req)
}

// ToggleBasic calls infinimesh.node.DevicesService.ToggleBasic.
func (c *devicesServiceClient) ToggleBasic(ctx context.Context, req *connect_go.Request[devices.Device]) (*connect_go.Response[devices.Device], error) {
	return c.toggleBasic.CallUnary(ctx, req)
}

// MakeDevicesToken calls infinimesh.node.DevicesService.MakeDevicesToken.
func (c *devicesServiceClient) MakeDevicesToken(ctx context.Context, req *connect_go.Request[node.DevicesTokenRequest]) (*connect_go.Response[node.TokenResponse], error) {
	return c.makeDevicesToken.CallUnary(ctx, req)
}

// Move calls infinimesh.node.DevicesService.Move.
func (c *devicesServiceClient) Move(ctx context.Context, req *connect_go.Request[node.MoveRequest]) (*connect_go.Response[node.EmptyMessage], error) {
	return c.move.CallUnary(ctx, req)
}

// Joins calls infinimesh.node.DevicesService.Joins.
func (c *devicesServiceClient) Joins(ctx context.Context, req *connect_go.Request[devices.Device]) (*connect_go.Response[access.Nodes], error) {
	return c.joins.CallUnary(ctx, req)
}

// Join calls infinimesh.node.DevicesService.Join.
func (c *devicesServiceClient) Join(ctx context.Context, req *connect_go.Request[node.JoinGeneralRequest]) (*connect_go.Response[access.Node], error) {
	return c.join.CallUnary(ctx, req)
}

// GetByToken calls infinimesh.node.DevicesService.GetByToken.
func (c *devicesServiceClient) GetByToken(ctx context.Context, req *connect_go.Request[devices.Device]) (*connect_go.Response[devices.Device], error) {
	return c.getByToken.CallUnary(ctx, req)
}

// GetByFingerprint calls infinimesh.node.DevicesService.GetByFingerprint.
func (c *devicesServiceClient) GetByFingerprint(ctx context.Context, req *connect_go.Request[devices.GetByFingerprintRequest]) (*connect_go.Response[devices.Device], error) {
	return c.getByFingerprint.CallUnary(ctx, req)
}

// DevicesServiceHandler is an implementation of the infinimesh.node.DevicesService service.
type DevicesServiceHandler interface {
	Get(context.Context, *connect_go.Request[devices.Device]) (*connect_go.Response[devices.Device], error)
	List(context.Context, *connect_go.Request[node.EmptyMessage]) (*connect_go.Response[devices.Devices], error)
	Create(context.Context, *connect_go.Request[devices.CreateRequest]) (*connect_go.Response[devices.CreateResponse], error)
	Update(context.Context, *connect_go.Request[devices.Device]) (*connect_go.Response[devices.Device], error)
	Delete(context.Context, *connect_go.Request[devices.Device]) (*connect_go.Response[node.DeleteResponse], error)
	Toggle(context.Context, *connect_go.Request[devices.Device]) (*connect_go.Response[devices.Device], error)
	ToggleBasic(context.Context, *connect_go.Request[devices.Device]) (*connect_go.Response[devices.Device], error)
	MakeDevicesToken(context.Context, *connect_go.Request[node.DevicesTokenRequest]) (*connect_go.Response[node.TokenResponse], error)
	// Moves Device between Namespaces
	Move(context.Context, *connect_go.Request[node.MoveRequest]) (*connect_go.Response[node.EmptyMessage], error)
	// Accounts and Namesapces having access to this Device
	Joins(context.Context, *connect_go.Request[devices.Device]) (*connect_go.Response[access.Nodes], error)
	// Sets Access to this namespace for the given Node(Account or Namespace) (deletes if level is set
	// to NONE(0))
	// Node is interpret as a Device (uuid is enough) and Join as an Account or Namespace (must be provided fully)
	Join(context.Context, *connect_go.Request[node.JoinGeneralRequest]) (*connect_go.Response[access.Node], error)
	GetByToken(context.Context, *connect_go.Request[devices.Device]) (*connect_go.Response[devices.Device], error)
	GetByFingerprint(context.Context, *connect_go.Request[devices.GetByFingerprintRequest]) (*connect_go.Response[devices.Device], error)
}

// NewDevicesServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewDevicesServiceHandler(svc DevicesServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/infinimesh.node.DevicesService/Get", connect_go.NewUnaryHandler(
		"/infinimesh.node.DevicesService/Get",
		svc.Get,
		opts...,
	))
	mux.Handle("/infinimesh.node.DevicesService/List", connect_go.NewUnaryHandler(
		"/infinimesh.node.DevicesService/List",
		svc.List,
		opts...,
	))
	mux.Handle("/infinimesh.node.DevicesService/Create", connect_go.NewUnaryHandler(
		"/infinimesh.node.DevicesService/Create",
		svc.Create,
		opts...,
	))
	mux.Handle("/infinimesh.node.DevicesService/Update", connect_go.NewUnaryHandler(
		"/infinimesh.node.DevicesService/Update",
		svc.Update,
		opts...,
	))
	mux.Handle("/infinimesh.node.DevicesService/Delete", connect_go.NewUnaryHandler(
		"/infinimesh.node.DevicesService/Delete",
		svc.Delete,
		opts...,
	))
	mux.Handle("/infinimesh.node.DevicesService/Toggle", connect_go.NewUnaryHandler(
		"/infinimesh.node.DevicesService/Toggle",
		svc.Toggle,
		opts...,
	))
	mux.Handle("/infinimesh.node.DevicesService/ToggleBasic", connect_go.NewUnaryHandler(
		"/infinimesh.node.DevicesService/ToggleBasic",
		svc.ToggleBasic,
		opts...,
	))
	mux.Handle("/infinimesh.node.DevicesService/MakeDevicesToken", connect_go.NewUnaryHandler(
		"/infinimesh.node.DevicesService/MakeDevicesToken",
		svc.MakeDevicesToken,
		opts...,
	))
	mux.Handle("/infinimesh.node.DevicesService/Move", connect_go.NewUnaryHandler(
		"/infinimesh.node.DevicesService/Move",
		svc.Move,
		opts...,
	))
	mux.Handle("/infinimesh.node.DevicesService/Joins", connect_go.NewUnaryHandler(
		"/infinimesh.node.DevicesService/Joins",
		svc.Joins,
		opts...,
	))
	mux.Handle("/infinimesh.node.DevicesService/Join", connect_go.NewUnaryHandler(
		"/infinimesh.node.DevicesService/Join",
		svc.Join,
		opts...,
	))
	mux.Handle("/infinimesh.node.DevicesService/GetByToken", connect_go.NewUnaryHandler(
		"/infinimesh.node.DevicesService/GetByToken",
		svc.GetByToken,
		opts...,
	))
	mux.Handle("/infinimesh.node.DevicesService/GetByFingerprint", connect_go.NewUnaryHandler(
		"/infinimesh.node.DevicesService/GetByFingerprint",
		svc.GetByFingerprint,
		opts...,
	))
	return "/infinimesh.node.DevicesService/", mux
}

// UnimplementedDevicesServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedDevicesServiceHandler struct{}

func (UnimplementedDevicesServiceHandler) Get(context.Context, *connect_go.Request[devices.Device]) (*connect_go.Response[devices.Device], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.Get is not implemented"))
}

func (UnimplementedDevicesServiceHandler) List(context.Context, *connect_go.Request[node.EmptyMessage]) (*connect_go.Response[devices.Devices], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.List is not implemented"))
}

func (UnimplementedDevicesServiceHandler) Create(context.Context, *connect_go.Request[devices.CreateRequest]) (*connect_go.Response[devices.CreateResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.Create is not implemented"))
}

func (UnimplementedDevicesServiceHandler) Update(context.Context, *connect_go.Request[devices.Device]) (*connect_go.Response[devices.Device], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.Update is not implemented"))
}

func (UnimplementedDevicesServiceHandler) Delete(context.Context, *connect_go.Request[devices.Device]) (*connect_go.Response[node.DeleteResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.Delete is not implemented"))
}

func (UnimplementedDevicesServiceHandler) Toggle(context.Context, *connect_go.Request[devices.Device]) (*connect_go.Response[devices.Device], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.Toggle is not implemented"))
}

func (UnimplementedDevicesServiceHandler) ToggleBasic(context.Context, *connect_go.Request[devices.Device]) (*connect_go.Response[devices.Device], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.ToggleBasic is not implemented"))
}

func (UnimplementedDevicesServiceHandler) MakeDevicesToken(context.Context, *connect_go.Request[node.DevicesTokenRequest]) (*connect_go.Response[node.TokenResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.MakeDevicesToken is not implemented"))
}

func (UnimplementedDevicesServiceHandler) Move(context.Context, *connect_go.Request[node.MoveRequest]) (*connect_go.Response[node.EmptyMessage], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.Move is not implemented"))
}

func (UnimplementedDevicesServiceHandler) Joins(context.Context, *connect_go.Request[devices.Device]) (*connect_go.Response[access.Nodes], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.Joins is not implemented"))
}

func (UnimplementedDevicesServiceHandler) Join(context.Context, *connect_go.Request[node.JoinGeneralRequest]) (*connect_go.Response[access.Node], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.Join is not implemented"))
}

func (UnimplementedDevicesServiceHandler) GetByToken(context.Context, *connect_go.Request[devices.Device]) (*connect_go.Response[devices.Device], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.GetByToken is not implemented"))
}

func (UnimplementedDevicesServiceHandler) GetByFingerprint(context.Context, *connect_go.Request[devices.GetByFingerprintRequest]) (*connect_go.Response[devices.Device], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.GetByFingerprint is not implemented"))
}

// ShadowServiceClient is a client for the infinimesh.node.ShadowService service.
type ShadowServiceClient interface {
	Get(context.Context, *connect_go.Request[shadow.GetRequest]) (*connect_go.Response[shadow.GetResponse], error)
	Patch(context.Context, *connect_go.Request[shadow.Shadow]) (*connect_go.Response[shadow.Shadow], error)
	Remove(context.Context, *connect_go.Request[shadow.RemoveRequest]) (*connect_go.Response[shadow.Shadow], error)
	StreamShadow(context.Context, *connect_go.Request[shadow.StreamShadowRequest]) (*connect_go.ServerStreamForClient[shadow.Shadow], error)
	StreamShadowSync(context.Context, *connect_go.Request[shadow.StreamShadowRequest]) (*connect_go.ServerStreamForClient[shadow.Shadow], error)
}

// NewShadowServiceClient constructs a client for the infinimesh.node.ShadowService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewShadowServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) ShadowServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &shadowServiceClient{
		get: connect_go.NewClient[shadow.GetRequest, shadow.GetResponse](
			httpClient,
			baseURL+"/infinimesh.node.ShadowService/Get",
			opts...,
		),
		patch: connect_go.NewClient[shadow.Shadow, shadow.Shadow](
			httpClient,
			baseURL+"/infinimesh.node.ShadowService/Patch",
			opts...,
		),
		remove: connect_go.NewClient[shadow.RemoveRequest, shadow.Shadow](
			httpClient,
			baseURL+"/infinimesh.node.ShadowService/Remove",
			opts...,
		),
		streamShadow: connect_go.NewClient[shadow.StreamShadowRequest, shadow.Shadow](
			httpClient,
			baseURL+"/infinimesh.node.ShadowService/StreamShadow",
			opts...,
		),
		streamShadowSync: connect_go.NewClient[shadow.StreamShadowRequest, shadow.Shadow](
			httpClient,
			baseURL+"/infinimesh.node.ShadowService/StreamShadowSync",
			opts...,
		),
	}
}

// shadowServiceClient implements ShadowServiceClient.
type shadowServiceClient struct {
	get              *connect_go.Client[shadow.GetRequest, shadow.GetResponse]
	patch            *connect_go.Client[shadow.Shadow, shadow.Shadow]
	remove           *connect_go.Client[shadow.RemoveRequest, shadow.Shadow]
	streamShadow     *connect_go.Client[shadow.StreamShadowRequest, shadow.Shadow]
	streamShadowSync *connect_go.Client[shadow.StreamShadowRequest, shadow.Shadow]
}

// Get calls infinimesh.node.ShadowService.Get.
func (c *shadowServiceClient) Get(ctx context.Context, req *connect_go.Request[shadow.GetRequest]) (*connect_go.Response[shadow.GetResponse], error) {
	return c.get.CallUnary(ctx, req)
}

// Patch calls infinimesh.node.ShadowService.Patch.
func (c *shadowServiceClient) Patch(ctx context.Context, req *connect_go.Request[shadow.Shadow]) (*connect_go.Response[shadow.Shadow], error) {
	return c.patch.CallUnary(ctx, req)
}

// Remove calls infinimesh.node.ShadowService.Remove.
func (c *shadowServiceClient) Remove(ctx context.Context, req *connect_go.Request[shadow.RemoveRequest]) (*connect_go.Response[shadow.Shadow], error) {
	return c.remove.CallUnary(ctx, req)
}

// StreamShadow calls infinimesh.node.ShadowService.StreamShadow.
func (c *shadowServiceClient) StreamShadow(ctx context.Context, req *connect_go.Request[shadow.StreamShadowRequest]) (*connect_go.ServerStreamForClient[shadow.Shadow], error) {
	return c.streamShadow.CallServerStream(ctx, req)
}

// StreamShadowSync calls infinimesh.node.ShadowService.StreamShadowSync.
func (c *shadowServiceClient) StreamShadowSync(ctx context.Context, req *connect_go.Request[shadow.StreamShadowRequest]) (*connect_go.ServerStreamForClient[shadow.Shadow], error) {
	return c.streamShadowSync.CallServerStream(ctx, req)
}

// ShadowServiceHandler is an implementation of the infinimesh.node.ShadowService service.
type ShadowServiceHandler interface {
	Get(context.Context, *connect_go.Request[shadow.GetRequest]) (*connect_go.Response[shadow.GetResponse], error)
	Patch(context.Context, *connect_go.Request[shadow.Shadow]) (*connect_go.Response[shadow.Shadow], error)
	Remove(context.Context, *connect_go.Request[shadow.RemoveRequest]) (*connect_go.Response[shadow.Shadow], error)
	StreamShadow(context.Context, *connect_go.Request[shadow.StreamShadowRequest], *connect_go.ServerStream[shadow.Shadow]) error
	StreamShadowSync(context.Context, *connect_go.Request[shadow.StreamShadowRequest], *connect_go.ServerStream[shadow.Shadow]) error
}

// NewShadowServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewShadowServiceHandler(svc ShadowServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/infinimesh.node.ShadowService/Get", connect_go.NewUnaryHandler(
		"/infinimesh.node.ShadowService/Get",
		svc.Get,
		opts...,
	))
	mux.Handle("/infinimesh.node.ShadowService/Patch", connect_go.NewUnaryHandler(
		"/infinimesh.node.ShadowService/Patch",
		svc.Patch,
		opts...,
	))
	mux.Handle("/infinimesh.node.ShadowService/Remove", connect_go.NewUnaryHandler(
		"/infinimesh.node.ShadowService/Remove",
		svc.Remove,
		opts...,
	))
	mux.Handle("/infinimesh.node.ShadowService/StreamShadow", connect_go.NewServerStreamHandler(
		"/infinimesh.node.ShadowService/StreamShadow",
		svc.StreamShadow,
		opts...,
	))
	mux.Handle("/infinimesh.node.ShadowService/StreamShadowSync", connect_go.NewServerStreamHandler(
		"/infinimesh.node.ShadowService/StreamShadowSync",
		svc.StreamShadowSync,
		opts...,
	))
	return "/infinimesh.node.ShadowService/", mux
}

// UnimplementedShadowServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedShadowServiceHandler struct{}

func (UnimplementedShadowServiceHandler) Get(context.Context, *connect_go.Request[shadow.GetRequest]) (*connect_go.Response[shadow.GetResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.ShadowService.Get is not implemented"))
}

func (UnimplementedShadowServiceHandler) Patch(context.Context, *connect_go.Request[shadow.Shadow]) (*connect_go.Response[shadow.Shadow], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.ShadowService.Patch is not implemented"))
}

func (UnimplementedShadowServiceHandler) Remove(context.Context, *connect_go.Request[shadow.RemoveRequest]) (*connect_go.Response[shadow.Shadow], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.ShadowService.Remove is not implemented"))
}

func (UnimplementedShadowServiceHandler) StreamShadow(context.Context, *connect_go.Request[shadow.StreamShadowRequest], *connect_go.ServerStream[shadow.Shadow]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.ShadowService.StreamShadow is not implemented"))
}

func (UnimplementedShadowServiceHandler) StreamShadowSync(context.Context, *connect_go.Request[shadow.StreamShadowRequest], *connect_go.ServerStream[shadow.Shadow]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.ShadowService.StreamShadowSync is not implemented"))
}

// InternalServiceClient is a client for the infinimesh.node.InternalService service.
type InternalServiceClient interface {
	GetLDAPProviders(context.Context, *connect_go.Request[node.EmptyMessage]) (*connect_go.Response[node.LDAPProviders], error)
}

// NewInternalServiceClient constructs a client for the infinimesh.node.InternalService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewInternalServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) InternalServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &internalServiceClient{
		getLDAPProviders: connect_go.NewClient[node.EmptyMessage, node.LDAPProviders](
			httpClient,
			baseURL+"/infinimesh.node.InternalService/GetLDAPProviders",
			opts...,
		),
	}
}

// internalServiceClient implements InternalServiceClient.
type internalServiceClient struct {
	getLDAPProviders *connect_go.Client[node.EmptyMessage, node.LDAPProviders]
}

// GetLDAPProviders calls infinimesh.node.InternalService.GetLDAPProviders.
func (c *internalServiceClient) GetLDAPProviders(ctx context.Context, req *connect_go.Request[node.EmptyMessage]) (*connect_go.Response[node.LDAPProviders], error) {
	return c.getLDAPProviders.CallUnary(ctx, req)
}

// InternalServiceHandler is an implementation of the infinimesh.node.InternalService service.
type InternalServiceHandler interface {
	GetLDAPProviders(context.Context, *connect_go.Request[node.EmptyMessage]) (*connect_go.Response[node.LDAPProviders], error)
}

// NewInternalServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewInternalServiceHandler(svc InternalServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/infinimesh.node.InternalService/GetLDAPProviders", connect_go.NewUnaryHandler(
		"/infinimesh.node.InternalService/GetLDAPProviders",
		svc.GetLDAPProviders,
		opts...,
	))
	return "/infinimesh.node.InternalService/", mux
}

// UnimplementedInternalServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedInternalServiceHandler struct{}

func (UnimplementedInternalServiceHandler) GetLDAPProviders(context.Context, *connect_go.Request[node.EmptyMessage]) (*connect_go.Response[node.LDAPProviders], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("infinimesh.node.InternalService.GetLDAPProviders is not implemented"))
}
