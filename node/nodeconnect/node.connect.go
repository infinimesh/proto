//
//Copyright Â© 2021-2023 Infinite Devices GmbH
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: node/node.proto

package nodeconnect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	node "github.com/infinimesh/proto/node"
	access "github.com/infinimesh/proto/node/access"
	accounts "github.com/infinimesh/proto/node/accounts"
	devices "github.com/infinimesh/proto/node/devices"
	namespaces "github.com/infinimesh/proto/node/namespaces"
	sessions "github.com/infinimesh/proto/node/sessions"
	shadow "github.com/infinimesh/proto/shadow"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// AccountsServiceName is the fully-qualified name of the AccountsService service.
	AccountsServiceName = "infinimesh.node.AccountsService"
	// SessionsServiceName is the fully-qualified name of the SessionsService service.
	SessionsServiceName = "infinimesh.node.SessionsService"
	// NamespacesServiceName is the fully-qualified name of the NamespacesService service.
	NamespacesServiceName = "infinimesh.node.NamespacesService"
	// DevicesServiceName is the fully-qualified name of the DevicesService service.
	DevicesServiceName = "infinimesh.node.DevicesService"
	// ShadowServiceName is the fully-qualified name of the ShadowService service.
	ShadowServiceName = "infinimesh.node.ShadowService"
	// InternalServiceName is the fully-qualified name of the InternalService service.
	InternalServiceName = "infinimesh.node.InternalService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// AccountsServiceTokenProcedure is the fully-qualified name of the AccountsService's Token RPC.
	AccountsServiceTokenProcedure = "/infinimesh.node.AccountsService/Token"
	// AccountsServiceGetProcedure is the fully-qualified name of the AccountsService's Get RPC.
	AccountsServiceGetProcedure = "/infinimesh.node.AccountsService/Get"
	// AccountsServiceListProcedure is the fully-qualified name of the AccountsService's List RPC.
	AccountsServiceListProcedure = "/infinimesh.node.AccountsService/List"
	// AccountsServiceCreateProcedure is the fully-qualified name of the AccountsService's Create RPC.
	AccountsServiceCreateProcedure = "/infinimesh.node.AccountsService/Create"
	// AccountsServiceUpdateProcedure is the fully-qualified name of the AccountsService's Update RPC.
	AccountsServiceUpdateProcedure = "/infinimesh.node.AccountsService/Update"
	// AccountsServiceToggleProcedure is the fully-qualified name of the AccountsService's Toggle RPC.
	AccountsServiceToggleProcedure = "/infinimesh.node.AccountsService/Toggle"
	// AccountsServiceDeleteProcedure is the fully-qualified name of the AccountsService's Delete RPC.
	AccountsServiceDeleteProcedure = "/infinimesh.node.AccountsService/Delete"
	// AccountsServiceAccessiblesProcedure is the fully-qualified name of the AccountsService's
	// Accessibles RPC.
	AccountsServiceAccessiblesProcedure = "/infinimesh.node.AccountsService/Accessibles"
	// AccountsServiceDeletablesProcedure is the fully-qualified name of the AccountsService's
	// Deletables RPC.
	AccountsServiceDeletablesProcedure = "/infinimesh.node.AccountsService/Deletables"
	// AccountsServiceMoveProcedure is the fully-qualified name of the AccountsService's Move RPC.
	AccountsServiceMoveProcedure = "/infinimesh.node.AccountsService/Move"
	// AccountsServiceGetCredentialsProcedure is the fully-qualified name of the AccountsService's
	// GetCredentials RPC.
	AccountsServiceGetCredentialsProcedure = "/infinimesh.node.AccountsService/GetCredentials"
	// AccountsServiceSetCredentialsProcedure is the fully-qualified name of the AccountsService's
	// SetCredentials RPC.
	AccountsServiceSetCredentialsProcedure = "/infinimesh.node.AccountsService/SetCredentials"
	// AccountsServiceDelCredentialsProcedure is the fully-qualified name of the AccountsService's
	// DelCredentials RPC.
	AccountsServiceDelCredentialsProcedure = "/infinimesh.node.AccountsService/DelCredentials"
	// SessionsServiceGetProcedure is the fully-qualified name of the SessionsService's Get RPC.
	SessionsServiceGetProcedure = "/infinimesh.node.SessionsService/Get"
	// SessionsServiceRevokeProcedure is the fully-qualified name of the SessionsService's Revoke RPC.
	SessionsServiceRevokeProcedure = "/infinimesh.node.SessionsService/Revoke"
	// SessionsServiceGetActivityProcedure is the fully-qualified name of the SessionsService's
	// GetActivity RPC.
	SessionsServiceGetActivityProcedure = "/infinimesh.node.SessionsService/GetActivity"
	// NamespacesServiceGetProcedure is the fully-qualified name of the NamespacesService's Get RPC.
	NamespacesServiceGetProcedure = "/infinimesh.node.NamespacesService/Get"
	// NamespacesServiceListProcedure is the fully-qualified name of the NamespacesService's List RPC.
	NamespacesServiceListProcedure = "/infinimesh.node.NamespacesService/List"
	// NamespacesServiceCreateProcedure is the fully-qualified name of the NamespacesService's Create
	// RPC.
	NamespacesServiceCreateProcedure = "/infinimesh.node.NamespacesService/Create"
	// NamespacesServiceUpdateProcedure is the fully-qualified name of the NamespacesService's Update
	// RPC.
	NamespacesServiceUpdateProcedure = "/infinimesh.node.NamespacesService/Update"
	// NamespacesServiceDeleteProcedure is the fully-qualified name of the NamespacesService's Delete
	// RPC.
	NamespacesServiceDeleteProcedure = "/infinimesh.node.NamespacesService/Delete"
	// NamespacesServiceAccessiblesProcedure is the fully-qualified name of the NamespacesService's
	// Accessibles RPC.
	NamespacesServiceAccessiblesProcedure = "/infinimesh.node.NamespacesService/Accessibles"
	// NamespacesServiceDeletablesProcedure is the fully-qualified name of the NamespacesService's
	// Deletables RPC.
	NamespacesServiceDeletablesProcedure = "/infinimesh.node.NamespacesService/Deletables"
	// NamespacesServiceJoinsProcedure is the fully-qualified name of the NamespacesService's Joins RPC.
	NamespacesServiceJoinsProcedure = "/infinimesh.node.NamespacesService/Joins"
	// NamespacesServiceJoinProcedure is the fully-qualified name of the NamespacesService's Join RPC.
	NamespacesServiceJoinProcedure = "/infinimesh.node.NamespacesService/Join"
	// DevicesServiceGetProcedure is the fully-qualified name of the DevicesService's Get RPC.
	DevicesServiceGetProcedure = "/infinimesh.node.DevicesService/Get"
	// DevicesServiceListProcedure is the fully-qualified name of the DevicesService's List RPC.
	DevicesServiceListProcedure = "/infinimesh.node.DevicesService/List"
	// DevicesServiceCreateProcedure is the fully-qualified name of the DevicesService's Create RPC.
	DevicesServiceCreateProcedure = "/infinimesh.node.DevicesService/Create"
	// DevicesServiceUpdateProcedure is the fully-qualified name of the DevicesService's Update RPC.
	DevicesServiceUpdateProcedure = "/infinimesh.node.DevicesService/Update"
	// DevicesServicePatchConfigProcedure is the fully-qualified name of the DevicesService's
	// PatchConfig RPC.
	DevicesServicePatchConfigProcedure = "/infinimesh.node.DevicesService/PatchConfig"
	// DevicesServiceDeleteProcedure is the fully-qualified name of the DevicesService's Delete RPC.
	DevicesServiceDeleteProcedure = "/infinimesh.node.DevicesService/Delete"
	// DevicesServiceToggleProcedure is the fully-qualified name of the DevicesService's Toggle RPC.
	DevicesServiceToggleProcedure = "/infinimesh.node.DevicesService/Toggle"
	// DevicesServiceToggleBasicProcedure is the fully-qualified name of the DevicesService's
	// ToggleBasic RPC.
	DevicesServiceToggleBasicProcedure = "/infinimesh.node.DevicesService/ToggleBasic"
	// DevicesServiceMakeDevicesTokenProcedure is the fully-qualified name of the DevicesService's
	// MakeDevicesToken RPC.
	DevicesServiceMakeDevicesTokenProcedure = "/infinimesh.node.DevicesService/MakeDevicesToken"
	// DevicesServiceMoveProcedure is the fully-qualified name of the DevicesService's Move RPC.
	DevicesServiceMoveProcedure = "/infinimesh.node.DevicesService/Move"
	// DevicesServiceJoinsProcedure is the fully-qualified name of the DevicesService's Joins RPC.
	DevicesServiceJoinsProcedure = "/infinimesh.node.DevicesService/Joins"
	// DevicesServiceJoinProcedure is the fully-qualified name of the DevicesService's Join RPC.
	DevicesServiceJoinProcedure = "/infinimesh.node.DevicesService/Join"
	// DevicesServiceGetByTokenProcedure is the fully-qualified name of the DevicesService's GetByToken
	// RPC.
	DevicesServiceGetByTokenProcedure = "/infinimesh.node.DevicesService/GetByToken"
	// DevicesServiceGetByFingerprintProcedure is the fully-qualified name of the DevicesService's
	// GetByFingerprint RPC.
	DevicesServiceGetByFingerprintProcedure = "/infinimesh.node.DevicesService/GetByFingerprint"
	// ShadowServiceGetProcedure is the fully-qualified name of the ShadowService's Get RPC.
	ShadowServiceGetProcedure = "/infinimesh.node.ShadowService/Get"
	// ShadowServicePatchProcedure is the fully-qualified name of the ShadowService's Patch RPC.
	ShadowServicePatchProcedure = "/infinimesh.node.ShadowService/Patch"
	// ShadowServiceRemoveProcedure is the fully-qualified name of the ShadowService's Remove RPC.
	ShadowServiceRemoveProcedure = "/infinimesh.node.ShadowService/Remove"
	// ShadowServiceStreamShadowProcedure is the fully-qualified name of the ShadowService's
	// StreamShadow RPC.
	ShadowServiceStreamShadowProcedure = "/infinimesh.node.ShadowService/StreamShadow"
	// ShadowServiceStreamShadowSyncProcedure is the fully-qualified name of the ShadowService's
	// StreamShadowSync RPC.
	ShadowServiceStreamShadowSyncProcedure = "/infinimesh.node.ShadowService/StreamShadowSync"
	// InternalServiceGetLDAPProvidersProcedure is the fully-qualified name of the InternalService's
	// GetLDAPProviders RPC.
	InternalServiceGetLDAPProvidersProcedure = "/infinimesh.node.InternalService/GetLDAPProviders"
)

// These variables are the protoreflect.Descriptor objects for the RPCs defined in this package.
var (
	accountsServiceServiceDescriptor                = node.File_node_node_proto.Services().ByName("AccountsService")
	accountsServiceTokenMethodDescriptor            = accountsServiceServiceDescriptor.Methods().ByName("Token")
	accountsServiceGetMethodDescriptor              = accountsServiceServiceDescriptor.Methods().ByName("Get")
	accountsServiceListMethodDescriptor             = accountsServiceServiceDescriptor.Methods().ByName("List")
	accountsServiceCreateMethodDescriptor           = accountsServiceServiceDescriptor.Methods().ByName("Create")
	accountsServiceUpdateMethodDescriptor           = accountsServiceServiceDescriptor.Methods().ByName("Update")
	accountsServiceToggleMethodDescriptor           = accountsServiceServiceDescriptor.Methods().ByName("Toggle")
	accountsServiceDeleteMethodDescriptor           = accountsServiceServiceDescriptor.Methods().ByName("Delete")
	accountsServiceAccessiblesMethodDescriptor      = accountsServiceServiceDescriptor.Methods().ByName("Accessibles")
	accountsServiceDeletablesMethodDescriptor       = accountsServiceServiceDescriptor.Methods().ByName("Deletables")
	accountsServiceMoveMethodDescriptor             = accountsServiceServiceDescriptor.Methods().ByName("Move")
	accountsServiceGetCredentialsMethodDescriptor   = accountsServiceServiceDescriptor.Methods().ByName("GetCredentials")
	accountsServiceSetCredentialsMethodDescriptor   = accountsServiceServiceDescriptor.Methods().ByName("SetCredentials")
	accountsServiceDelCredentialsMethodDescriptor   = accountsServiceServiceDescriptor.Methods().ByName("DelCredentials")
	sessionsServiceServiceDescriptor                = node.File_node_node_proto.Services().ByName("SessionsService")
	sessionsServiceGetMethodDescriptor              = sessionsServiceServiceDescriptor.Methods().ByName("Get")
	sessionsServiceRevokeMethodDescriptor           = sessionsServiceServiceDescriptor.Methods().ByName("Revoke")
	sessionsServiceGetActivityMethodDescriptor      = sessionsServiceServiceDescriptor.Methods().ByName("GetActivity")
	namespacesServiceServiceDescriptor              = node.File_node_node_proto.Services().ByName("NamespacesService")
	namespacesServiceGetMethodDescriptor            = namespacesServiceServiceDescriptor.Methods().ByName("Get")
	namespacesServiceListMethodDescriptor           = namespacesServiceServiceDescriptor.Methods().ByName("List")
	namespacesServiceCreateMethodDescriptor         = namespacesServiceServiceDescriptor.Methods().ByName("Create")
	namespacesServiceUpdateMethodDescriptor         = namespacesServiceServiceDescriptor.Methods().ByName("Update")
	namespacesServiceDeleteMethodDescriptor         = namespacesServiceServiceDescriptor.Methods().ByName("Delete")
	namespacesServiceAccessiblesMethodDescriptor    = namespacesServiceServiceDescriptor.Methods().ByName("Accessibles")
	namespacesServiceDeletablesMethodDescriptor     = namespacesServiceServiceDescriptor.Methods().ByName("Deletables")
	namespacesServiceJoinsMethodDescriptor          = namespacesServiceServiceDescriptor.Methods().ByName("Joins")
	namespacesServiceJoinMethodDescriptor           = namespacesServiceServiceDescriptor.Methods().ByName("Join")
	devicesServiceServiceDescriptor                 = node.File_node_node_proto.Services().ByName("DevicesService")
	devicesServiceGetMethodDescriptor               = devicesServiceServiceDescriptor.Methods().ByName("Get")
	devicesServiceListMethodDescriptor              = devicesServiceServiceDescriptor.Methods().ByName("List")
	devicesServiceCreateMethodDescriptor            = devicesServiceServiceDescriptor.Methods().ByName("Create")
	devicesServiceUpdateMethodDescriptor            = devicesServiceServiceDescriptor.Methods().ByName("Update")
	devicesServicePatchConfigMethodDescriptor       = devicesServiceServiceDescriptor.Methods().ByName("PatchConfig")
	devicesServiceDeleteMethodDescriptor            = devicesServiceServiceDescriptor.Methods().ByName("Delete")
	devicesServiceToggleMethodDescriptor            = devicesServiceServiceDescriptor.Methods().ByName("Toggle")
	devicesServiceToggleBasicMethodDescriptor       = devicesServiceServiceDescriptor.Methods().ByName("ToggleBasic")
	devicesServiceMakeDevicesTokenMethodDescriptor  = devicesServiceServiceDescriptor.Methods().ByName("MakeDevicesToken")
	devicesServiceMoveMethodDescriptor              = devicesServiceServiceDescriptor.Methods().ByName("Move")
	devicesServiceJoinsMethodDescriptor             = devicesServiceServiceDescriptor.Methods().ByName("Joins")
	devicesServiceJoinMethodDescriptor              = devicesServiceServiceDescriptor.Methods().ByName("Join")
	devicesServiceGetByTokenMethodDescriptor        = devicesServiceServiceDescriptor.Methods().ByName("GetByToken")
	devicesServiceGetByFingerprintMethodDescriptor  = devicesServiceServiceDescriptor.Methods().ByName("GetByFingerprint")
	shadowServiceServiceDescriptor                  = node.File_node_node_proto.Services().ByName("ShadowService")
	shadowServiceGetMethodDescriptor                = shadowServiceServiceDescriptor.Methods().ByName("Get")
	shadowServicePatchMethodDescriptor              = shadowServiceServiceDescriptor.Methods().ByName("Patch")
	shadowServiceRemoveMethodDescriptor             = shadowServiceServiceDescriptor.Methods().ByName("Remove")
	shadowServiceStreamShadowMethodDescriptor       = shadowServiceServiceDescriptor.Methods().ByName("StreamShadow")
	shadowServiceStreamShadowSyncMethodDescriptor   = shadowServiceServiceDescriptor.Methods().ByName("StreamShadowSync")
	internalServiceServiceDescriptor                = node.File_node_node_proto.Services().ByName("InternalService")
	internalServiceGetLDAPProvidersMethodDescriptor = internalServiceServiceDescriptor.Methods().ByName("GetLDAPProviders")
)

// AccountsServiceClient is a client for the infinimesh.node.AccountsService service.
type AccountsServiceClient interface {
	Token(context.Context, *connect.Request[node.TokenRequest]) (*connect.Response[node.TokenResponse], error)
	Get(context.Context, *connect.Request[accounts.Account]) (*connect.Response[accounts.Account], error)
	List(context.Context, *connect.Request[node.EmptyMessage]) (*connect.Response[accounts.Accounts], error)
	Create(context.Context, *connect.Request[accounts.CreateRequest]) (*connect.Response[accounts.CreateResponse], error)
	Update(context.Context, *connect.Request[accounts.Account]) (*connect.Response[accounts.Account], error)
	Toggle(context.Context, *connect.Request[accounts.Account]) (*connect.Response[accounts.Account], error)
	Delete(context.Context, *connect.Request[accounts.Account]) (*connect.Response[node.DeleteResponse], error)
	Accessibles(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[access.Nodes], error)
	Deletables(context.Context, *connect.Request[accounts.Account]) (*connect.Response[access.Nodes], error)
	Move(context.Context, *connect.Request[node.MoveRequest]) (*connect.Response[node.EmptyMessage], error)
	GetCredentials(context.Context, *connect.Request[node.GetCredentialsRequest]) (*connect.Response[node.GetCredentialsResponse], error)
	SetCredentials(context.Context, *connect.Request[node.SetCredentialsRequest]) (*connect.Response[node.SetCredentialsResponse], error)
	DelCredentials(context.Context, *connect.Request[node.DeleteCredentialsRequest]) (*connect.Response[node.DeleteResponse], error)
}

// NewAccountsServiceClient constructs a client for the infinimesh.node.AccountsService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewAccountsServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) AccountsServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &accountsServiceClient{
		token: connect.NewClient[node.TokenRequest, node.TokenResponse](
			httpClient,
			baseURL+AccountsServiceTokenProcedure,
			connect.WithSchema(accountsServiceTokenMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		get: connect.NewClient[accounts.Account, accounts.Account](
			httpClient,
			baseURL+AccountsServiceGetProcedure,
			connect.WithSchema(accountsServiceGetMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		list: connect.NewClient[node.EmptyMessage, accounts.Accounts](
			httpClient,
			baseURL+AccountsServiceListProcedure,
			connect.WithSchema(accountsServiceListMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		create: connect.NewClient[accounts.CreateRequest, accounts.CreateResponse](
			httpClient,
			baseURL+AccountsServiceCreateProcedure,
			connect.WithSchema(accountsServiceCreateMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		update: connect.NewClient[accounts.Account, accounts.Account](
			httpClient,
			baseURL+AccountsServiceUpdateProcedure,
			connect.WithSchema(accountsServiceUpdateMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		toggle: connect.NewClient[accounts.Account, accounts.Account](
			httpClient,
			baseURL+AccountsServiceToggleProcedure,
			connect.WithSchema(accountsServiceToggleMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		delete: connect.NewClient[accounts.Account, node.DeleteResponse](
			httpClient,
			baseURL+AccountsServiceDeleteProcedure,
			connect.WithSchema(accountsServiceDeleteMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		accessibles: connect.NewClient[namespaces.Namespace, access.Nodes](
			httpClient,
			baseURL+AccountsServiceAccessiblesProcedure,
			connect.WithSchema(accountsServiceAccessiblesMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		deletables: connect.NewClient[accounts.Account, access.Nodes](
			httpClient,
			baseURL+AccountsServiceDeletablesProcedure,
			connect.WithSchema(accountsServiceDeletablesMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		move: connect.NewClient[node.MoveRequest, node.EmptyMessage](
			httpClient,
			baseURL+AccountsServiceMoveProcedure,
			connect.WithSchema(accountsServiceMoveMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		getCredentials: connect.NewClient[node.GetCredentialsRequest, node.GetCredentialsResponse](
			httpClient,
			baseURL+AccountsServiceGetCredentialsProcedure,
			connect.WithSchema(accountsServiceGetCredentialsMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		setCredentials: connect.NewClient[node.SetCredentialsRequest, node.SetCredentialsResponse](
			httpClient,
			baseURL+AccountsServiceSetCredentialsProcedure,
			connect.WithSchema(accountsServiceSetCredentialsMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		delCredentials: connect.NewClient[node.DeleteCredentialsRequest, node.DeleteResponse](
			httpClient,
			baseURL+AccountsServiceDelCredentialsProcedure,
			connect.WithSchema(accountsServiceDelCredentialsMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
	}
}

// accountsServiceClient implements AccountsServiceClient.
type accountsServiceClient struct {
	token          *connect.Client[node.TokenRequest, node.TokenResponse]
	get            *connect.Client[accounts.Account, accounts.Account]
	list           *connect.Client[node.EmptyMessage, accounts.Accounts]
	create         *connect.Client[accounts.CreateRequest, accounts.CreateResponse]
	update         *connect.Client[accounts.Account, accounts.Account]
	toggle         *connect.Client[accounts.Account, accounts.Account]
	delete         *connect.Client[accounts.Account, node.DeleteResponse]
	accessibles    *connect.Client[namespaces.Namespace, access.Nodes]
	deletables     *connect.Client[accounts.Account, access.Nodes]
	move           *connect.Client[node.MoveRequest, node.EmptyMessage]
	getCredentials *connect.Client[node.GetCredentialsRequest, node.GetCredentialsResponse]
	setCredentials *connect.Client[node.SetCredentialsRequest, node.SetCredentialsResponse]
	delCredentials *connect.Client[node.DeleteCredentialsRequest, node.DeleteResponse]
}

// Token calls infinimesh.node.AccountsService.Token.
func (c *accountsServiceClient) Token(ctx context.Context, req *connect.Request[node.TokenRequest]) (*connect.Response[node.TokenResponse], error) {
	return c.token.CallUnary(ctx, req)
}

// Get calls infinimesh.node.AccountsService.Get.
func (c *accountsServiceClient) Get(ctx context.Context, req *connect.Request[accounts.Account]) (*connect.Response[accounts.Account], error) {
	return c.get.CallUnary(ctx, req)
}

// List calls infinimesh.node.AccountsService.List.
func (c *accountsServiceClient) List(ctx context.Context, req *connect.Request[node.EmptyMessage]) (*connect.Response[accounts.Accounts], error) {
	return c.list.CallUnary(ctx, req)
}

// Create calls infinimesh.node.AccountsService.Create.
func (c *accountsServiceClient) Create(ctx context.Context, req *connect.Request[accounts.CreateRequest]) (*connect.Response[accounts.CreateResponse], error) {
	return c.create.CallUnary(ctx, req)
}

// Update calls infinimesh.node.AccountsService.Update.
func (c *accountsServiceClient) Update(ctx context.Context, req *connect.Request[accounts.Account]) (*connect.Response[accounts.Account], error) {
	return c.update.CallUnary(ctx, req)
}

// Toggle calls infinimesh.node.AccountsService.Toggle.
func (c *accountsServiceClient) Toggle(ctx context.Context, req *connect.Request[accounts.Account]) (*connect.Response[accounts.Account], error) {
	return c.toggle.CallUnary(ctx, req)
}

// Delete calls infinimesh.node.AccountsService.Delete.
func (c *accountsServiceClient) Delete(ctx context.Context, req *connect.Request[accounts.Account]) (*connect.Response[node.DeleteResponse], error) {
	return c.delete.CallUnary(ctx, req)
}

// Accessibles calls infinimesh.node.AccountsService.Accessibles.
func (c *accountsServiceClient) Accessibles(ctx context.Context, req *connect.Request[namespaces.Namespace]) (*connect.Response[access.Nodes], error) {
	return c.accessibles.CallUnary(ctx, req)
}

// Deletables calls infinimesh.node.AccountsService.Deletables.
func (c *accountsServiceClient) Deletables(ctx context.Context, req *connect.Request[accounts.Account]) (*connect.Response[access.Nodes], error) {
	return c.deletables.CallUnary(ctx, req)
}

// Move calls infinimesh.node.AccountsService.Move.
func (c *accountsServiceClient) Move(ctx context.Context, req *connect.Request[node.MoveRequest]) (*connect.Response[node.EmptyMessage], error) {
	return c.move.CallUnary(ctx, req)
}

// GetCredentials calls infinimesh.node.AccountsService.GetCredentials.
func (c *accountsServiceClient) GetCredentials(ctx context.Context, req *connect.Request[node.GetCredentialsRequest]) (*connect.Response[node.GetCredentialsResponse], error) {
	return c.getCredentials.CallUnary(ctx, req)
}

// SetCredentials calls infinimesh.node.AccountsService.SetCredentials.
func (c *accountsServiceClient) SetCredentials(ctx context.Context, req *connect.Request[node.SetCredentialsRequest]) (*connect.Response[node.SetCredentialsResponse], error) {
	return c.setCredentials.CallUnary(ctx, req)
}

// DelCredentials calls infinimesh.node.AccountsService.DelCredentials.
func (c *accountsServiceClient) DelCredentials(ctx context.Context, req *connect.Request[node.DeleteCredentialsRequest]) (*connect.Response[node.DeleteResponse], error) {
	return c.delCredentials.CallUnary(ctx, req)
}

// AccountsServiceHandler is an implementation of the infinimesh.node.AccountsService service.
type AccountsServiceHandler interface {
	Token(context.Context, *connect.Request[node.TokenRequest]) (*connect.Response[node.TokenResponse], error)
	Get(context.Context, *connect.Request[accounts.Account]) (*connect.Response[accounts.Account], error)
	List(context.Context, *connect.Request[node.EmptyMessage]) (*connect.Response[accounts.Accounts], error)
	Create(context.Context, *connect.Request[accounts.CreateRequest]) (*connect.Response[accounts.CreateResponse], error)
	Update(context.Context, *connect.Request[accounts.Account]) (*connect.Response[accounts.Account], error)
	Toggle(context.Context, *connect.Request[accounts.Account]) (*connect.Response[accounts.Account], error)
	Delete(context.Context, *connect.Request[accounts.Account]) (*connect.Response[node.DeleteResponse], error)
	Accessibles(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[access.Nodes], error)
	Deletables(context.Context, *connect.Request[accounts.Account]) (*connect.Response[access.Nodes], error)
	Move(context.Context, *connect.Request[node.MoveRequest]) (*connect.Response[node.EmptyMessage], error)
	GetCredentials(context.Context, *connect.Request[node.GetCredentialsRequest]) (*connect.Response[node.GetCredentialsResponse], error)
	SetCredentials(context.Context, *connect.Request[node.SetCredentialsRequest]) (*connect.Response[node.SetCredentialsResponse], error)
	DelCredentials(context.Context, *connect.Request[node.DeleteCredentialsRequest]) (*connect.Response[node.DeleteResponse], error)
}

// NewAccountsServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewAccountsServiceHandler(svc AccountsServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	accountsServiceTokenHandler := connect.NewUnaryHandler(
		AccountsServiceTokenProcedure,
		svc.Token,
		connect.WithSchema(accountsServiceTokenMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	accountsServiceGetHandler := connect.NewUnaryHandler(
		AccountsServiceGetProcedure,
		svc.Get,
		connect.WithSchema(accountsServiceGetMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	accountsServiceListHandler := connect.NewUnaryHandler(
		AccountsServiceListProcedure,
		svc.List,
		connect.WithSchema(accountsServiceListMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	accountsServiceCreateHandler := connect.NewUnaryHandler(
		AccountsServiceCreateProcedure,
		svc.Create,
		connect.WithSchema(accountsServiceCreateMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	accountsServiceUpdateHandler := connect.NewUnaryHandler(
		AccountsServiceUpdateProcedure,
		svc.Update,
		connect.WithSchema(accountsServiceUpdateMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	accountsServiceToggleHandler := connect.NewUnaryHandler(
		AccountsServiceToggleProcedure,
		svc.Toggle,
		connect.WithSchema(accountsServiceToggleMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	accountsServiceDeleteHandler := connect.NewUnaryHandler(
		AccountsServiceDeleteProcedure,
		svc.Delete,
		connect.WithSchema(accountsServiceDeleteMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	accountsServiceAccessiblesHandler := connect.NewUnaryHandler(
		AccountsServiceAccessiblesProcedure,
		svc.Accessibles,
		connect.WithSchema(accountsServiceAccessiblesMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	accountsServiceDeletablesHandler := connect.NewUnaryHandler(
		AccountsServiceDeletablesProcedure,
		svc.Deletables,
		connect.WithSchema(accountsServiceDeletablesMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	accountsServiceMoveHandler := connect.NewUnaryHandler(
		AccountsServiceMoveProcedure,
		svc.Move,
		connect.WithSchema(accountsServiceMoveMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	accountsServiceGetCredentialsHandler := connect.NewUnaryHandler(
		AccountsServiceGetCredentialsProcedure,
		svc.GetCredentials,
		connect.WithSchema(accountsServiceGetCredentialsMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	accountsServiceSetCredentialsHandler := connect.NewUnaryHandler(
		AccountsServiceSetCredentialsProcedure,
		svc.SetCredentials,
		connect.WithSchema(accountsServiceSetCredentialsMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	accountsServiceDelCredentialsHandler := connect.NewUnaryHandler(
		AccountsServiceDelCredentialsProcedure,
		svc.DelCredentials,
		connect.WithSchema(accountsServiceDelCredentialsMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	return "/infinimesh.node.AccountsService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case AccountsServiceTokenProcedure:
			accountsServiceTokenHandler.ServeHTTP(w, r)
		case AccountsServiceGetProcedure:
			accountsServiceGetHandler.ServeHTTP(w, r)
		case AccountsServiceListProcedure:
			accountsServiceListHandler.ServeHTTP(w, r)
		case AccountsServiceCreateProcedure:
			accountsServiceCreateHandler.ServeHTTP(w, r)
		case AccountsServiceUpdateProcedure:
			accountsServiceUpdateHandler.ServeHTTP(w, r)
		case AccountsServiceToggleProcedure:
			accountsServiceToggleHandler.ServeHTTP(w, r)
		case AccountsServiceDeleteProcedure:
			accountsServiceDeleteHandler.ServeHTTP(w, r)
		case AccountsServiceAccessiblesProcedure:
			accountsServiceAccessiblesHandler.ServeHTTP(w, r)
		case AccountsServiceDeletablesProcedure:
			accountsServiceDeletablesHandler.ServeHTTP(w, r)
		case AccountsServiceMoveProcedure:
			accountsServiceMoveHandler.ServeHTTP(w, r)
		case AccountsServiceGetCredentialsProcedure:
			accountsServiceGetCredentialsHandler.ServeHTTP(w, r)
		case AccountsServiceSetCredentialsProcedure:
			accountsServiceSetCredentialsHandler.ServeHTTP(w, r)
		case AccountsServiceDelCredentialsProcedure:
			accountsServiceDelCredentialsHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedAccountsServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedAccountsServiceHandler struct{}

func (UnimplementedAccountsServiceHandler) Token(context.Context, *connect.Request[node.TokenRequest]) (*connect.Response[node.TokenResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.Token is not implemented"))
}

func (UnimplementedAccountsServiceHandler) Get(context.Context, *connect.Request[accounts.Account]) (*connect.Response[accounts.Account], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.Get is not implemented"))
}

func (UnimplementedAccountsServiceHandler) List(context.Context, *connect.Request[node.EmptyMessage]) (*connect.Response[accounts.Accounts], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.List is not implemented"))
}

func (UnimplementedAccountsServiceHandler) Create(context.Context, *connect.Request[accounts.CreateRequest]) (*connect.Response[accounts.CreateResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.Create is not implemented"))
}

func (UnimplementedAccountsServiceHandler) Update(context.Context, *connect.Request[accounts.Account]) (*connect.Response[accounts.Account], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.Update is not implemented"))
}

func (UnimplementedAccountsServiceHandler) Toggle(context.Context, *connect.Request[accounts.Account]) (*connect.Response[accounts.Account], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.Toggle is not implemented"))
}

func (UnimplementedAccountsServiceHandler) Delete(context.Context, *connect.Request[accounts.Account]) (*connect.Response[node.DeleteResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.Delete is not implemented"))
}

func (UnimplementedAccountsServiceHandler) Accessibles(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[access.Nodes], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.Accessibles is not implemented"))
}

func (UnimplementedAccountsServiceHandler) Deletables(context.Context, *connect.Request[accounts.Account]) (*connect.Response[access.Nodes], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.Deletables is not implemented"))
}

func (UnimplementedAccountsServiceHandler) Move(context.Context, *connect.Request[node.MoveRequest]) (*connect.Response[node.EmptyMessage], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.Move is not implemented"))
}

func (UnimplementedAccountsServiceHandler) GetCredentials(context.Context, *connect.Request[node.GetCredentialsRequest]) (*connect.Response[node.GetCredentialsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.GetCredentials is not implemented"))
}

func (UnimplementedAccountsServiceHandler) SetCredentials(context.Context, *connect.Request[node.SetCredentialsRequest]) (*connect.Response[node.SetCredentialsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.SetCredentials is not implemented"))
}

func (UnimplementedAccountsServiceHandler) DelCredentials(context.Context, *connect.Request[node.DeleteCredentialsRequest]) (*connect.Response[node.DeleteResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.AccountsService.DelCredentials is not implemented"))
}

// SessionsServiceClient is a client for the infinimesh.node.SessionsService service.
type SessionsServiceClient interface {
	Get(context.Context, *connect.Request[node.EmptyMessage]) (*connect.Response[sessions.Sessions], error)
	Revoke(context.Context, *connect.Request[sessions.Session]) (*connect.Response[node.DeleteResponse], error)
	GetActivity(context.Context, *connect.Request[node.EmptyMessage]) (*connect.Response[sessions.Activity], error)
}

// NewSessionsServiceClient constructs a client for the infinimesh.node.SessionsService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewSessionsServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) SessionsServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &sessionsServiceClient{
		get: connect.NewClient[node.EmptyMessage, sessions.Sessions](
			httpClient,
			baseURL+SessionsServiceGetProcedure,
			connect.WithSchema(sessionsServiceGetMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		revoke: connect.NewClient[sessions.Session, node.DeleteResponse](
			httpClient,
			baseURL+SessionsServiceRevokeProcedure,
			connect.WithSchema(sessionsServiceRevokeMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		getActivity: connect.NewClient[node.EmptyMessage, sessions.Activity](
			httpClient,
			baseURL+SessionsServiceGetActivityProcedure,
			connect.WithSchema(sessionsServiceGetActivityMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
	}
}

// sessionsServiceClient implements SessionsServiceClient.
type sessionsServiceClient struct {
	get         *connect.Client[node.EmptyMessage, sessions.Sessions]
	revoke      *connect.Client[sessions.Session, node.DeleteResponse]
	getActivity *connect.Client[node.EmptyMessage, sessions.Activity]
}

// Get calls infinimesh.node.SessionsService.Get.
func (c *sessionsServiceClient) Get(ctx context.Context, req *connect.Request[node.EmptyMessage]) (*connect.Response[sessions.Sessions], error) {
	return c.get.CallUnary(ctx, req)
}

// Revoke calls infinimesh.node.SessionsService.Revoke.
func (c *sessionsServiceClient) Revoke(ctx context.Context, req *connect.Request[sessions.Session]) (*connect.Response[node.DeleteResponse], error) {
	return c.revoke.CallUnary(ctx, req)
}

// GetActivity calls infinimesh.node.SessionsService.GetActivity.
func (c *sessionsServiceClient) GetActivity(ctx context.Context, req *connect.Request[node.EmptyMessage]) (*connect.Response[sessions.Activity], error) {
	return c.getActivity.CallUnary(ctx, req)
}

// SessionsServiceHandler is an implementation of the infinimesh.node.SessionsService service.
type SessionsServiceHandler interface {
	Get(context.Context, *connect.Request[node.EmptyMessage]) (*connect.Response[sessions.Sessions], error)
	Revoke(context.Context, *connect.Request[sessions.Session]) (*connect.Response[node.DeleteResponse], error)
	GetActivity(context.Context, *connect.Request[node.EmptyMessage]) (*connect.Response[sessions.Activity], error)
}

// NewSessionsServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewSessionsServiceHandler(svc SessionsServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	sessionsServiceGetHandler := connect.NewUnaryHandler(
		SessionsServiceGetProcedure,
		svc.Get,
		connect.WithSchema(sessionsServiceGetMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	sessionsServiceRevokeHandler := connect.NewUnaryHandler(
		SessionsServiceRevokeProcedure,
		svc.Revoke,
		connect.WithSchema(sessionsServiceRevokeMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	sessionsServiceGetActivityHandler := connect.NewUnaryHandler(
		SessionsServiceGetActivityProcedure,
		svc.GetActivity,
		connect.WithSchema(sessionsServiceGetActivityMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	return "/infinimesh.node.SessionsService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case SessionsServiceGetProcedure:
			sessionsServiceGetHandler.ServeHTTP(w, r)
		case SessionsServiceRevokeProcedure:
			sessionsServiceRevokeHandler.ServeHTTP(w, r)
		case SessionsServiceGetActivityProcedure:
			sessionsServiceGetActivityHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedSessionsServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedSessionsServiceHandler struct{}

func (UnimplementedSessionsServiceHandler) Get(context.Context, *connect.Request[node.EmptyMessage]) (*connect.Response[sessions.Sessions], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.SessionsService.Get is not implemented"))
}

func (UnimplementedSessionsServiceHandler) Revoke(context.Context, *connect.Request[sessions.Session]) (*connect.Response[node.DeleteResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.SessionsService.Revoke is not implemented"))
}

func (UnimplementedSessionsServiceHandler) GetActivity(context.Context, *connect.Request[node.EmptyMessage]) (*connect.Response[sessions.Activity], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.SessionsService.GetActivity is not implemented"))
}

// NamespacesServiceClient is a client for the infinimesh.node.NamespacesService service.
type NamespacesServiceClient interface {
	Get(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[namespaces.Namespace], error)
	List(context.Context, *connect.Request[node.EmptyMessage]) (*connect.Response[namespaces.Namespaces], error)
	Create(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[namespaces.Namespace], error)
	Update(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[namespaces.Namespace], error)
	Delete(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[node.DeleteResponse], error)
	Accessibles(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[access.Nodes], error)
	Deletables(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[access.Nodes], error)
	// Accounts having access to this namespace
	Joins(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[accounts.Accounts], error)
	// Sets Access to this namespace for the given account(deletes if level is set
	// to NONE(0))
	Join(context.Context, *connect.Request[node.JoinRequest]) (*connect.Response[accounts.Accounts], error)
}

// NewNamespacesServiceClient constructs a client for the infinimesh.node.NamespacesService service.
// By default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped
// responses, and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewNamespacesServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) NamespacesServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &namespacesServiceClient{
		get: connect.NewClient[namespaces.Namespace, namespaces.Namespace](
			httpClient,
			baseURL+NamespacesServiceGetProcedure,
			connect.WithSchema(namespacesServiceGetMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		list: connect.NewClient[node.EmptyMessage, namespaces.Namespaces](
			httpClient,
			baseURL+NamespacesServiceListProcedure,
			connect.WithSchema(namespacesServiceListMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		create: connect.NewClient[namespaces.Namespace, namespaces.Namespace](
			httpClient,
			baseURL+NamespacesServiceCreateProcedure,
			connect.WithSchema(namespacesServiceCreateMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		update: connect.NewClient[namespaces.Namespace, namespaces.Namespace](
			httpClient,
			baseURL+NamespacesServiceUpdateProcedure,
			connect.WithSchema(namespacesServiceUpdateMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		delete: connect.NewClient[namespaces.Namespace, node.DeleteResponse](
			httpClient,
			baseURL+NamespacesServiceDeleteProcedure,
			connect.WithSchema(namespacesServiceDeleteMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		accessibles: connect.NewClient[namespaces.Namespace, access.Nodes](
			httpClient,
			baseURL+NamespacesServiceAccessiblesProcedure,
			connect.WithSchema(namespacesServiceAccessiblesMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		deletables: connect.NewClient[namespaces.Namespace, access.Nodes](
			httpClient,
			baseURL+NamespacesServiceDeletablesProcedure,
			connect.WithSchema(namespacesServiceDeletablesMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		joins: connect.NewClient[namespaces.Namespace, accounts.Accounts](
			httpClient,
			baseURL+NamespacesServiceJoinsProcedure,
			connect.WithSchema(namespacesServiceJoinsMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		join: connect.NewClient[node.JoinRequest, accounts.Accounts](
			httpClient,
			baseURL+NamespacesServiceJoinProcedure,
			connect.WithSchema(namespacesServiceJoinMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
	}
}

// namespacesServiceClient implements NamespacesServiceClient.
type namespacesServiceClient struct {
	get         *connect.Client[namespaces.Namespace, namespaces.Namespace]
	list        *connect.Client[node.EmptyMessage, namespaces.Namespaces]
	create      *connect.Client[namespaces.Namespace, namespaces.Namespace]
	update      *connect.Client[namespaces.Namespace, namespaces.Namespace]
	delete      *connect.Client[namespaces.Namespace, node.DeleteResponse]
	accessibles *connect.Client[namespaces.Namespace, access.Nodes]
	deletables  *connect.Client[namespaces.Namespace, access.Nodes]
	joins       *connect.Client[namespaces.Namespace, accounts.Accounts]
	join        *connect.Client[node.JoinRequest, accounts.Accounts]
}

// Get calls infinimesh.node.NamespacesService.Get.
func (c *namespacesServiceClient) Get(ctx context.Context, req *connect.Request[namespaces.Namespace]) (*connect.Response[namespaces.Namespace], error) {
	return c.get.CallUnary(ctx, req)
}

// List calls infinimesh.node.NamespacesService.List.
func (c *namespacesServiceClient) List(ctx context.Context, req *connect.Request[node.EmptyMessage]) (*connect.Response[namespaces.Namespaces], error) {
	return c.list.CallUnary(ctx, req)
}

// Create calls infinimesh.node.NamespacesService.Create.
func (c *namespacesServiceClient) Create(ctx context.Context, req *connect.Request[namespaces.Namespace]) (*connect.Response[namespaces.Namespace], error) {
	return c.create.CallUnary(ctx, req)
}

// Update calls infinimesh.node.NamespacesService.Update.
func (c *namespacesServiceClient) Update(ctx context.Context, req *connect.Request[namespaces.Namespace]) (*connect.Response[namespaces.Namespace], error) {
	return c.update.CallUnary(ctx, req)
}

// Delete calls infinimesh.node.NamespacesService.Delete.
func (c *namespacesServiceClient) Delete(ctx context.Context, req *connect.Request[namespaces.Namespace]) (*connect.Response[node.DeleteResponse], error) {
	return c.delete.CallUnary(ctx, req)
}

// Accessibles calls infinimesh.node.NamespacesService.Accessibles.
func (c *namespacesServiceClient) Accessibles(ctx context.Context, req *connect.Request[namespaces.Namespace]) (*connect.Response[access.Nodes], error) {
	return c.accessibles.CallUnary(ctx, req)
}

// Deletables calls infinimesh.node.NamespacesService.Deletables.
func (c *namespacesServiceClient) Deletables(ctx context.Context, req *connect.Request[namespaces.Namespace]) (*connect.Response[access.Nodes], error) {
	return c.deletables.CallUnary(ctx, req)
}

// Joins calls infinimesh.node.NamespacesService.Joins.
func (c *namespacesServiceClient) Joins(ctx context.Context, req *connect.Request[namespaces.Namespace]) (*connect.Response[accounts.Accounts], error) {
	return c.joins.CallUnary(ctx, req)
}

// Join calls infinimesh.node.NamespacesService.Join.
func (c *namespacesServiceClient) Join(ctx context.Context, req *connect.Request[node.JoinRequest]) (*connect.Response[accounts.Accounts], error) {
	return c.join.CallUnary(ctx, req)
}

// NamespacesServiceHandler is an implementation of the infinimesh.node.NamespacesService service.
type NamespacesServiceHandler interface {
	Get(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[namespaces.Namespace], error)
	List(context.Context, *connect.Request[node.EmptyMessage]) (*connect.Response[namespaces.Namespaces], error)
	Create(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[namespaces.Namespace], error)
	Update(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[namespaces.Namespace], error)
	Delete(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[node.DeleteResponse], error)
	Accessibles(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[access.Nodes], error)
	Deletables(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[access.Nodes], error)
	// Accounts having access to this namespace
	Joins(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[accounts.Accounts], error)
	// Sets Access to this namespace for the given account(deletes if level is set
	// to NONE(0))
	Join(context.Context, *connect.Request[node.JoinRequest]) (*connect.Response[accounts.Accounts], error)
}

// NewNamespacesServiceHandler builds an HTTP handler from the service implementation. It returns
// the path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewNamespacesServiceHandler(svc NamespacesServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	namespacesServiceGetHandler := connect.NewUnaryHandler(
		NamespacesServiceGetProcedure,
		svc.Get,
		connect.WithSchema(namespacesServiceGetMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	namespacesServiceListHandler := connect.NewUnaryHandler(
		NamespacesServiceListProcedure,
		svc.List,
		connect.WithSchema(namespacesServiceListMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	namespacesServiceCreateHandler := connect.NewUnaryHandler(
		NamespacesServiceCreateProcedure,
		svc.Create,
		connect.WithSchema(namespacesServiceCreateMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	namespacesServiceUpdateHandler := connect.NewUnaryHandler(
		NamespacesServiceUpdateProcedure,
		svc.Update,
		connect.WithSchema(namespacesServiceUpdateMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	namespacesServiceDeleteHandler := connect.NewUnaryHandler(
		NamespacesServiceDeleteProcedure,
		svc.Delete,
		connect.WithSchema(namespacesServiceDeleteMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	namespacesServiceAccessiblesHandler := connect.NewUnaryHandler(
		NamespacesServiceAccessiblesProcedure,
		svc.Accessibles,
		connect.WithSchema(namespacesServiceAccessiblesMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	namespacesServiceDeletablesHandler := connect.NewUnaryHandler(
		NamespacesServiceDeletablesProcedure,
		svc.Deletables,
		connect.WithSchema(namespacesServiceDeletablesMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	namespacesServiceJoinsHandler := connect.NewUnaryHandler(
		NamespacesServiceJoinsProcedure,
		svc.Joins,
		connect.WithSchema(namespacesServiceJoinsMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	namespacesServiceJoinHandler := connect.NewUnaryHandler(
		NamespacesServiceJoinProcedure,
		svc.Join,
		connect.WithSchema(namespacesServiceJoinMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	return "/infinimesh.node.NamespacesService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case NamespacesServiceGetProcedure:
			namespacesServiceGetHandler.ServeHTTP(w, r)
		case NamespacesServiceListProcedure:
			namespacesServiceListHandler.ServeHTTP(w, r)
		case NamespacesServiceCreateProcedure:
			namespacesServiceCreateHandler.ServeHTTP(w, r)
		case NamespacesServiceUpdateProcedure:
			namespacesServiceUpdateHandler.ServeHTTP(w, r)
		case NamespacesServiceDeleteProcedure:
			namespacesServiceDeleteHandler.ServeHTTP(w, r)
		case NamespacesServiceAccessiblesProcedure:
			namespacesServiceAccessiblesHandler.ServeHTTP(w, r)
		case NamespacesServiceDeletablesProcedure:
			namespacesServiceDeletablesHandler.ServeHTTP(w, r)
		case NamespacesServiceJoinsProcedure:
			namespacesServiceJoinsHandler.ServeHTTP(w, r)
		case NamespacesServiceJoinProcedure:
			namespacesServiceJoinHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedNamespacesServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedNamespacesServiceHandler struct{}

func (UnimplementedNamespacesServiceHandler) Get(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[namespaces.Namespace], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.NamespacesService.Get is not implemented"))
}

func (UnimplementedNamespacesServiceHandler) List(context.Context, *connect.Request[node.EmptyMessage]) (*connect.Response[namespaces.Namespaces], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.NamespacesService.List is not implemented"))
}

func (UnimplementedNamespacesServiceHandler) Create(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[namespaces.Namespace], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.NamespacesService.Create is not implemented"))
}

func (UnimplementedNamespacesServiceHandler) Update(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[namespaces.Namespace], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.NamespacesService.Update is not implemented"))
}

func (UnimplementedNamespacesServiceHandler) Delete(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[node.DeleteResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.NamespacesService.Delete is not implemented"))
}

func (UnimplementedNamespacesServiceHandler) Accessibles(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[access.Nodes], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.NamespacesService.Accessibles is not implemented"))
}

func (UnimplementedNamespacesServiceHandler) Deletables(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[access.Nodes], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.NamespacesService.Deletables is not implemented"))
}

func (UnimplementedNamespacesServiceHandler) Joins(context.Context, *connect.Request[namespaces.Namespace]) (*connect.Response[accounts.Accounts], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.NamespacesService.Joins is not implemented"))
}

func (UnimplementedNamespacesServiceHandler) Join(context.Context, *connect.Request[node.JoinRequest]) (*connect.Response[accounts.Accounts], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.NamespacesService.Join is not implemented"))
}

// DevicesServiceClient is a client for the infinimesh.node.DevicesService service.
type DevicesServiceClient interface {
	Get(context.Context, *connect.Request[devices.Device]) (*connect.Response[devices.Device], error)
	List(context.Context, *connect.Request[node.QueryRequest]) (*connect.Response[devices.Devices], error)
	Create(context.Context, *connect.Request[devices.CreateRequest]) (*connect.Response[devices.CreateResponse], error)
	Update(context.Context, *connect.Request[devices.Device]) (*connect.Response[devices.Device], error)
	PatchConfig(context.Context, *connect.Request[devices.Device]) (*connect.Response[devices.Device], error)
	Delete(context.Context, *connect.Request[devices.Device]) (*connect.Response[node.DeleteResponse], error)
	Toggle(context.Context, *connect.Request[devices.Device]) (*connect.Response[devices.Device], error)
	ToggleBasic(context.Context, *connect.Request[devices.Device]) (*connect.Response[devices.Device], error)
	MakeDevicesToken(context.Context, *connect.Request[node.DevicesTokenRequest]) (*connect.Response[node.TokenResponse], error)
	// Moves Device between Namespaces
	Move(context.Context, *connect.Request[node.MoveRequest]) (*connect.Response[node.EmptyMessage], error)
	// Accounts and Namesapces having access to this Device
	Joins(context.Context, *connect.Request[devices.Device]) (*connect.Response[access.Nodes], error)
	// Sets Access to this namespace for the given Node(Account or Namespace)
	// (deletes if level is set to NONE(0)) Node is interpret as a Device (uuid is
	// enough) and Join as an Account or Namespace (must be provided fully)
	Join(context.Context, *connect.Request[node.JoinGeneralRequest]) (*connect.Response[access.Node], error)
	GetByToken(context.Context, *connect.Request[devices.Device]) (*connect.Response[devices.Device], error)
	GetByFingerprint(context.Context, *connect.Request[devices.GetByFingerprintRequest]) (*connect.Response[devices.Device], error)
}

// NewDevicesServiceClient constructs a client for the infinimesh.node.DevicesService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewDevicesServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) DevicesServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &devicesServiceClient{
		get: connect.NewClient[devices.Device, devices.Device](
			httpClient,
			baseURL+DevicesServiceGetProcedure,
			connect.WithSchema(devicesServiceGetMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		list: connect.NewClient[node.QueryRequest, devices.Devices](
			httpClient,
			baseURL+DevicesServiceListProcedure,
			connect.WithSchema(devicesServiceListMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		create: connect.NewClient[devices.CreateRequest, devices.CreateResponse](
			httpClient,
			baseURL+DevicesServiceCreateProcedure,
			connect.WithSchema(devicesServiceCreateMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		update: connect.NewClient[devices.Device, devices.Device](
			httpClient,
			baseURL+DevicesServiceUpdateProcedure,
			connect.WithSchema(devicesServiceUpdateMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		patchConfig: connect.NewClient[devices.Device, devices.Device](
			httpClient,
			baseURL+DevicesServicePatchConfigProcedure,
			connect.WithSchema(devicesServicePatchConfigMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		delete: connect.NewClient[devices.Device, node.DeleteResponse](
			httpClient,
			baseURL+DevicesServiceDeleteProcedure,
			connect.WithSchema(devicesServiceDeleteMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		toggle: connect.NewClient[devices.Device, devices.Device](
			httpClient,
			baseURL+DevicesServiceToggleProcedure,
			connect.WithSchema(devicesServiceToggleMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		toggleBasic: connect.NewClient[devices.Device, devices.Device](
			httpClient,
			baseURL+DevicesServiceToggleBasicProcedure,
			connect.WithSchema(devicesServiceToggleBasicMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		makeDevicesToken: connect.NewClient[node.DevicesTokenRequest, node.TokenResponse](
			httpClient,
			baseURL+DevicesServiceMakeDevicesTokenProcedure,
			connect.WithSchema(devicesServiceMakeDevicesTokenMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		move: connect.NewClient[node.MoveRequest, node.EmptyMessage](
			httpClient,
			baseURL+DevicesServiceMoveProcedure,
			connect.WithSchema(devicesServiceMoveMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		joins: connect.NewClient[devices.Device, access.Nodes](
			httpClient,
			baseURL+DevicesServiceJoinsProcedure,
			connect.WithSchema(devicesServiceJoinsMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		join: connect.NewClient[node.JoinGeneralRequest, access.Node](
			httpClient,
			baseURL+DevicesServiceJoinProcedure,
			connect.WithSchema(devicesServiceJoinMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		getByToken: connect.NewClient[devices.Device, devices.Device](
			httpClient,
			baseURL+DevicesServiceGetByTokenProcedure,
			connect.WithSchema(devicesServiceGetByTokenMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		getByFingerprint: connect.NewClient[devices.GetByFingerprintRequest, devices.Device](
			httpClient,
			baseURL+DevicesServiceGetByFingerprintProcedure,
			connect.WithSchema(devicesServiceGetByFingerprintMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
	}
}

// devicesServiceClient implements DevicesServiceClient.
type devicesServiceClient struct {
	get              *connect.Client[devices.Device, devices.Device]
	list             *connect.Client[node.QueryRequest, devices.Devices]
	create           *connect.Client[devices.CreateRequest, devices.CreateResponse]
	update           *connect.Client[devices.Device, devices.Device]
	patchConfig      *connect.Client[devices.Device, devices.Device]
	delete           *connect.Client[devices.Device, node.DeleteResponse]
	toggle           *connect.Client[devices.Device, devices.Device]
	toggleBasic      *connect.Client[devices.Device, devices.Device]
	makeDevicesToken *connect.Client[node.DevicesTokenRequest, node.TokenResponse]
	move             *connect.Client[node.MoveRequest, node.EmptyMessage]
	joins            *connect.Client[devices.Device, access.Nodes]
	join             *connect.Client[node.JoinGeneralRequest, access.Node]
	getByToken       *connect.Client[devices.Device, devices.Device]
	getByFingerprint *connect.Client[devices.GetByFingerprintRequest, devices.Device]
}

// Get calls infinimesh.node.DevicesService.Get.
func (c *devicesServiceClient) Get(ctx context.Context, req *connect.Request[devices.Device]) (*connect.Response[devices.Device], error) {
	return c.get.CallUnary(ctx, req)
}

// List calls infinimesh.node.DevicesService.List.
func (c *devicesServiceClient) List(ctx context.Context, req *connect.Request[node.QueryRequest]) (*connect.Response[devices.Devices], error) {
	return c.list.CallUnary(ctx, req)
}

// Create calls infinimesh.node.DevicesService.Create.
func (c *devicesServiceClient) Create(ctx context.Context, req *connect.Request[devices.CreateRequest]) (*connect.Response[devices.CreateResponse], error) {
	return c.create.CallUnary(ctx, req)
}

// Update calls infinimesh.node.DevicesService.Update.
func (c *devicesServiceClient) Update(ctx context.Context, req *connect.Request[devices.Device]) (*connect.Response[devices.Device], error) {
	return c.update.CallUnary(ctx, req)
}

// PatchConfig calls infinimesh.node.DevicesService.PatchConfig.
func (c *devicesServiceClient) PatchConfig(ctx context.Context, req *connect.Request[devices.Device]) (*connect.Response[devices.Device], error) {
	return c.patchConfig.CallUnary(ctx, req)
}

// Delete calls infinimesh.node.DevicesService.Delete.
func (c *devicesServiceClient) Delete(ctx context.Context, req *connect.Request[devices.Device]) (*connect.Response[node.DeleteResponse], error) {
	return c.delete.CallUnary(ctx, req)
}

// Toggle calls infinimesh.node.DevicesService.Toggle.
func (c *devicesServiceClient) Toggle(ctx context.Context, req *connect.Request[devices.Device]) (*connect.Response[devices.Device], error) {
	return c.toggle.CallUnary(ctx, req)
}

// ToggleBasic calls infinimesh.node.DevicesService.ToggleBasic.
func (c *devicesServiceClient) ToggleBasic(ctx context.Context, req *connect.Request[devices.Device]) (*connect.Response[devices.Device], error) {
	return c.toggleBasic.CallUnary(ctx, req)
}

// MakeDevicesToken calls infinimesh.node.DevicesService.MakeDevicesToken.
func (c *devicesServiceClient) MakeDevicesToken(ctx context.Context, req *connect.Request[node.DevicesTokenRequest]) (*connect.Response[node.TokenResponse], error) {
	return c.makeDevicesToken.CallUnary(ctx, req)
}

// Move calls infinimesh.node.DevicesService.Move.
func (c *devicesServiceClient) Move(ctx context.Context, req *connect.Request[node.MoveRequest]) (*connect.Response[node.EmptyMessage], error) {
	return c.move.CallUnary(ctx, req)
}

// Joins calls infinimesh.node.DevicesService.Joins.
func (c *devicesServiceClient) Joins(ctx context.Context, req *connect.Request[devices.Device]) (*connect.Response[access.Nodes], error) {
	return c.joins.CallUnary(ctx, req)
}

// Join calls infinimesh.node.DevicesService.Join.
func (c *devicesServiceClient) Join(ctx context.Context, req *connect.Request[node.JoinGeneralRequest]) (*connect.Response[access.Node], error) {
	return c.join.CallUnary(ctx, req)
}

// GetByToken calls infinimesh.node.DevicesService.GetByToken.
func (c *devicesServiceClient) GetByToken(ctx context.Context, req *connect.Request[devices.Device]) (*connect.Response[devices.Device], error) {
	return c.getByToken.CallUnary(ctx, req)
}

// GetByFingerprint calls infinimesh.node.DevicesService.GetByFingerprint.
func (c *devicesServiceClient) GetByFingerprint(ctx context.Context, req *connect.Request[devices.GetByFingerprintRequest]) (*connect.Response[devices.Device], error) {
	return c.getByFingerprint.CallUnary(ctx, req)
}

// DevicesServiceHandler is an implementation of the infinimesh.node.DevicesService service.
type DevicesServiceHandler interface {
	Get(context.Context, *connect.Request[devices.Device]) (*connect.Response[devices.Device], error)
	List(context.Context, *connect.Request[node.QueryRequest]) (*connect.Response[devices.Devices], error)
	Create(context.Context, *connect.Request[devices.CreateRequest]) (*connect.Response[devices.CreateResponse], error)
	Update(context.Context, *connect.Request[devices.Device]) (*connect.Response[devices.Device], error)
	PatchConfig(context.Context, *connect.Request[devices.Device]) (*connect.Response[devices.Device], error)
	Delete(context.Context, *connect.Request[devices.Device]) (*connect.Response[node.DeleteResponse], error)
	Toggle(context.Context, *connect.Request[devices.Device]) (*connect.Response[devices.Device], error)
	ToggleBasic(context.Context, *connect.Request[devices.Device]) (*connect.Response[devices.Device], error)
	MakeDevicesToken(context.Context, *connect.Request[node.DevicesTokenRequest]) (*connect.Response[node.TokenResponse], error)
	// Moves Device between Namespaces
	Move(context.Context, *connect.Request[node.MoveRequest]) (*connect.Response[node.EmptyMessage], error)
	// Accounts and Namesapces having access to this Device
	Joins(context.Context, *connect.Request[devices.Device]) (*connect.Response[access.Nodes], error)
	// Sets Access to this namespace for the given Node(Account or Namespace)
	// (deletes if level is set to NONE(0)) Node is interpret as a Device (uuid is
	// enough) and Join as an Account or Namespace (must be provided fully)
	Join(context.Context, *connect.Request[node.JoinGeneralRequest]) (*connect.Response[access.Node], error)
	GetByToken(context.Context, *connect.Request[devices.Device]) (*connect.Response[devices.Device], error)
	GetByFingerprint(context.Context, *connect.Request[devices.GetByFingerprintRequest]) (*connect.Response[devices.Device], error)
}

// NewDevicesServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewDevicesServiceHandler(svc DevicesServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	devicesServiceGetHandler := connect.NewUnaryHandler(
		DevicesServiceGetProcedure,
		svc.Get,
		connect.WithSchema(devicesServiceGetMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	devicesServiceListHandler := connect.NewUnaryHandler(
		DevicesServiceListProcedure,
		svc.List,
		connect.WithSchema(devicesServiceListMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	devicesServiceCreateHandler := connect.NewUnaryHandler(
		DevicesServiceCreateProcedure,
		svc.Create,
		connect.WithSchema(devicesServiceCreateMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	devicesServiceUpdateHandler := connect.NewUnaryHandler(
		DevicesServiceUpdateProcedure,
		svc.Update,
		connect.WithSchema(devicesServiceUpdateMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	devicesServicePatchConfigHandler := connect.NewUnaryHandler(
		DevicesServicePatchConfigProcedure,
		svc.PatchConfig,
		connect.WithSchema(devicesServicePatchConfigMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	devicesServiceDeleteHandler := connect.NewUnaryHandler(
		DevicesServiceDeleteProcedure,
		svc.Delete,
		connect.WithSchema(devicesServiceDeleteMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	devicesServiceToggleHandler := connect.NewUnaryHandler(
		DevicesServiceToggleProcedure,
		svc.Toggle,
		connect.WithSchema(devicesServiceToggleMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	devicesServiceToggleBasicHandler := connect.NewUnaryHandler(
		DevicesServiceToggleBasicProcedure,
		svc.ToggleBasic,
		connect.WithSchema(devicesServiceToggleBasicMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	devicesServiceMakeDevicesTokenHandler := connect.NewUnaryHandler(
		DevicesServiceMakeDevicesTokenProcedure,
		svc.MakeDevicesToken,
		connect.WithSchema(devicesServiceMakeDevicesTokenMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	devicesServiceMoveHandler := connect.NewUnaryHandler(
		DevicesServiceMoveProcedure,
		svc.Move,
		connect.WithSchema(devicesServiceMoveMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	devicesServiceJoinsHandler := connect.NewUnaryHandler(
		DevicesServiceJoinsProcedure,
		svc.Joins,
		connect.WithSchema(devicesServiceJoinsMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	devicesServiceJoinHandler := connect.NewUnaryHandler(
		DevicesServiceJoinProcedure,
		svc.Join,
		connect.WithSchema(devicesServiceJoinMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	devicesServiceGetByTokenHandler := connect.NewUnaryHandler(
		DevicesServiceGetByTokenProcedure,
		svc.GetByToken,
		connect.WithSchema(devicesServiceGetByTokenMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	devicesServiceGetByFingerprintHandler := connect.NewUnaryHandler(
		DevicesServiceGetByFingerprintProcedure,
		svc.GetByFingerprint,
		connect.WithSchema(devicesServiceGetByFingerprintMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	return "/infinimesh.node.DevicesService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case DevicesServiceGetProcedure:
			devicesServiceGetHandler.ServeHTTP(w, r)
		case DevicesServiceListProcedure:
			devicesServiceListHandler.ServeHTTP(w, r)
		case DevicesServiceCreateProcedure:
			devicesServiceCreateHandler.ServeHTTP(w, r)
		case DevicesServiceUpdateProcedure:
			devicesServiceUpdateHandler.ServeHTTP(w, r)
		case DevicesServicePatchConfigProcedure:
			devicesServicePatchConfigHandler.ServeHTTP(w, r)
		case DevicesServiceDeleteProcedure:
			devicesServiceDeleteHandler.ServeHTTP(w, r)
		case DevicesServiceToggleProcedure:
			devicesServiceToggleHandler.ServeHTTP(w, r)
		case DevicesServiceToggleBasicProcedure:
			devicesServiceToggleBasicHandler.ServeHTTP(w, r)
		case DevicesServiceMakeDevicesTokenProcedure:
			devicesServiceMakeDevicesTokenHandler.ServeHTTP(w, r)
		case DevicesServiceMoveProcedure:
			devicesServiceMoveHandler.ServeHTTP(w, r)
		case DevicesServiceJoinsProcedure:
			devicesServiceJoinsHandler.ServeHTTP(w, r)
		case DevicesServiceJoinProcedure:
			devicesServiceJoinHandler.ServeHTTP(w, r)
		case DevicesServiceGetByTokenProcedure:
			devicesServiceGetByTokenHandler.ServeHTTP(w, r)
		case DevicesServiceGetByFingerprintProcedure:
			devicesServiceGetByFingerprintHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedDevicesServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedDevicesServiceHandler struct{}

func (UnimplementedDevicesServiceHandler) Get(context.Context, *connect.Request[devices.Device]) (*connect.Response[devices.Device], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.Get is not implemented"))
}

func (UnimplementedDevicesServiceHandler) List(context.Context, *connect.Request[node.QueryRequest]) (*connect.Response[devices.Devices], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.List is not implemented"))
}

func (UnimplementedDevicesServiceHandler) Create(context.Context, *connect.Request[devices.CreateRequest]) (*connect.Response[devices.CreateResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.Create is not implemented"))
}

func (UnimplementedDevicesServiceHandler) Update(context.Context, *connect.Request[devices.Device]) (*connect.Response[devices.Device], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.Update is not implemented"))
}

func (UnimplementedDevicesServiceHandler) PatchConfig(context.Context, *connect.Request[devices.Device]) (*connect.Response[devices.Device], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.PatchConfig is not implemented"))
}

func (UnimplementedDevicesServiceHandler) Delete(context.Context, *connect.Request[devices.Device]) (*connect.Response[node.DeleteResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.Delete is not implemented"))
}

func (UnimplementedDevicesServiceHandler) Toggle(context.Context, *connect.Request[devices.Device]) (*connect.Response[devices.Device], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.Toggle is not implemented"))
}

func (UnimplementedDevicesServiceHandler) ToggleBasic(context.Context, *connect.Request[devices.Device]) (*connect.Response[devices.Device], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.ToggleBasic is not implemented"))
}

func (UnimplementedDevicesServiceHandler) MakeDevicesToken(context.Context, *connect.Request[node.DevicesTokenRequest]) (*connect.Response[node.TokenResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.MakeDevicesToken is not implemented"))
}

func (UnimplementedDevicesServiceHandler) Move(context.Context, *connect.Request[node.MoveRequest]) (*connect.Response[node.EmptyMessage], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.Move is not implemented"))
}

func (UnimplementedDevicesServiceHandler) Joins(context.Context, *connect.Request[devices.Device]) (*connect.Response[access.Nodes], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.Joins is not implemented"))
}

func (UnimplementedDevicesServiceHandler) Join(context.Context, *connect.Request[node.JoinGeneralRequest]) (*connect.Response[access.Node], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.Join is not implemented"))
}

func (UnimplementedDevicesServiceHandler) GetByToken(context.Context, *connect.Request[devices.Device]) (*connect.Response[devices.Device], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.GetByToken is not implemented"))
}

func (UnimplementedDevicesServiceHandler) GetByFingerprint(context.Context, *connect.Request[devices.GetByFingerprintRequest]) (*connect.Response[devices.Device], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.DevicesService.GetByFingerprint is not implemented"))
}

// ShadowServiceClient is a client for the infinimesh.node.ShadowService service.
type ShadowServiceClient interface {
	Get(context.Context, *connect.Request[shadow.GetRequest]) (*connect.Response[shadow.GetResponse], error)
	Patch(context.Context, *connect.Request[shadow.Shadow]) (*connect.Response[shadow.Shadow], error)
	Remove(context.Context, *connect.Request[shadow.RemoveRequest]) (*connect.Response[shadow.Shadow], error)
	StreamShadow(context.Context, *connect.Request[shadow.StreamShadowRequest]) (*connect.ServerStreamForClient[shadow.Shadow], error)
	StreamShadowSync(context.Context, *connect.Request[shadow.StreamShadowRequest]) (*connect.ServerStreamForClient[shadow.Shadow], error)
}

// NewShadowServiceClient constructs a client for the infinimesh.node.ShadowService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewShadowServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) ShadowServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &shadowServiceClient{
		get: connect.NewClient[shadow.GetRequest, shadow.GetResponse](
			httpClient,
			baseURL+ShadowServiceGetProcedure,
			connect.WithSchema(shadowServiceGetMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		patch: connect.NewClient[shadow.Shadow, shadow.Shadow](
			httpClient,
			baseURL+ShadowServicePatchProcedure,
			connect.WithSchema(shadowServicePatchMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		remove: connect.NewClient[shadow.RemoveRequest, shadow.Shadow](
			httpClient,
			baseURL+ShadowServiceRemoveProcedure,
			connect.WithSchema(shadowServiceRemoveMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		streamShadow: connect.NewClient[shadow.StreamShadowRequest, shadow.Shadow](
			httpClient,
			baseURL+ShadowServiceStreamShadowProcedure,
			connect.WithSchema(shadowServiceStreamShadowMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		streamShadowSync: connect.NewClient[shadow.StreamShadowRequest, shadow.Shadow](
			httpClient,
			baseURL+ShadowServiceStreamShadowSyncProcedure,
			connect.WithSchema(shadowServiceStreamShadowSyncMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
	}
}

// shadowServiceClient implements ShadowServiceClient.
type shadowServiceClient struct {
	get              *connect.Client[shadow.GetRequest, shadow.GetResponse]
	patch            *connect.Client[shadow.Shadow, shadow.Shadow]
	remove           *connect.Client[shadow.RemoveRequest, shadow.Shadow]
	streamShadow     *connect.Client[shadow.StreamShadowRequest, shadow.Shadow]
	streamShadowSync *connect.Client[shadow.StreamShadowRequest, shadow.Shadow]
}

// Get calls infinimesh.node.ShadowService.Get.
func (c *shadowServiceClient) Get(ctx context.Context, req *connect.Request[shadow.GetRequest]) (*connect.Response[shadow.GetResponse], error) {
	return c.get.CallUnary(ctx, req)
}

// Patch calls infinimesh.node.ShadowService.Patch.
func (c *shadowServiceClient) Patch(ctx context.Context, req *connect.Request[shadow.Shadow]) (*connect.Response[shadow.Shadow], error) {
	return c.patch.CallUnary(ctx, req)
}

// Remove calls infinimesh.node.ShadowService.Remove.
func (c *shadowServiceClient) Remove(ctx context.Context, req *connect.Request[shadow.RemoveRequest]) (*connect.Response[shadow.Shadow], error) {
	return c.remove.CallUnary(ctx, req)
}

// StreamShadow calls infinimesh.node.ShadowService.StreamShadow.
func (c *shadowServiceClient) StreamShadow(ctx context.Context, req *connect.Request[shadow.StreamShadowRequest]) (*connect.ServerStreamForClient[shadow.Shadow], error) {
	return c.streamShadow.CallServerStream(ctx, req)
}

// StreamShadowSync calls infinimesh.node.ShadowService.StreamShadowSync.
func (c *shadowServiceClient) StreamShadowSync(ctx context.Context, req *connect.Request[shadow.StreamShadowRequest]) (*connect.ServerStreamForClient[shadow.Shadow], error) {
	return c.streamShadowSync.CallServerStream(ctx, req)
}

// ShadowServiceHandler is an implementation of the infinimesh.node.ShadowService service.
type ShadowServiceHandler interface {
	Get(context.Context, *connect.Request[shadow.GetRequest]) (*connect.Response[shadow.GetResponse], error)
	Patch(context.Context, *connect.Request[shadow.Shadow]) (*connect.Response[shadow.Shadow], error)
	Remove(context.Context, *connect.Request[shadow.RemoveRequest]) (*connect.Response[shadow.Shadow], error)
	StreamShadow(context.Context, *connect.Request[shadow.StreamShadowRequest], *connect.ServerStream[shadow.Shadow]) error
	StreamShadowSync(context.Context, *connect.Request[shadow.StreamShadowRequest], *connect.ServerStream[shadow.Shadow]) error
}

// NewShadowServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewShadowServiceHandler(svc ShadowServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	shadowServiceGetHandler := connect.NewUnaryHandler(
		ShadowServiceGetProcedure,
		svc.Get,
		connect.WithSchema(shadowServiceGetMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	shadowServicePatchHandler := connect.NewUnaryHandler(
		ShadowServicePatchProcedure,
		svc.Patch,
		connect.WithSchema(shadowServicePatchMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	shadowServiceRemoveHandler := connect.NewUnaryHandler(
		ShadowServiceRemoveProcedure,
		svc.Remove,
		connect.WithSchema(shadowServiceRemoveMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	shadowServiceStreamShadowHandler := connect.NewServerStreamHandler(
		ShadowServiceStreamShadowProcedure,
		svc.StreamShadow,
		connect.WithSchema(shadowServiceStreamShadowMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	shadowServiceStreamShadowSyncHandler := connect.NewServerStreamHandler(
		ShadowServiceStreamShadowSyncProcedure,
		svc.StreamShadowSync,
		connect.WithSchema(shadowServiceStreamShadowSyncMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	return "/infinimesh.node.ShadowService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case ShadowServiceGetProcedure:
			shadowServiceGetHandler.ServeHTTP(w, r)
		case ShadowServicePatchProcedure:
			shadowServicePatchHandler.ServeHTTP(w, r)
		case ShadowServiceRemoveProcedure:
			shadowServiceRemoveHandler.ServeHTTP(w, r)
		case ShadowServiceStreamShadowProcedure:
			shadowServiceStreamShadowHandler.ServeHTTP(w, r)
		case ShadowServiceStreamShadowSyncProcedure:
			shadowServiceStreamShadowSyncHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedShadowServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedShadowServiceHandler struct{}

func (UnimplementedShadowServiceHandler) Get(context.Context, *connect.Request[shadow.GetRequest]) (*connect.Response[shadow.GetResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.ShadowService.Get is not implemented"))
}

func (UnimplementedShadowServiceHandler) Patch(context.Context, *connect.Request[shadow.Shadow]) (*connect.Response[shadow.Shadow], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.ShadowService.Patch is not implemented"))
}

func (UnimplementedShadowServiceHandler) Remove(context.Context, *connect.Request[shadow.RemoveRequest]) (*connect.Response[shadow.Shadow], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.ShadowService.Remove is not implemented"))
}

func (UnimplementedShadowServiceHandler) StreamShadow(context.Context, *connect.Request[shadow.StreamShadowRequest], *connect.ServerStream[shadow.Shadow]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.ShadowService.StreamShadow is not implemented"))
}

func (UnimplementedShadowServiceHandler) StreamShadowSync(context.Context, *connect.Request[shadow.StreamShadowRequest], *connect.ServerStream[shadow.Shadow]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.ShadowService.StreamShadowSync is not implemented"))
}

// InternalServiceClient is a client for the infinimesh.node.InternalService service.
type InternalServiceClient interface {
	GetLDAPProviders(context.Context, *connect.Request[node.EmptyMessage]) (*connect.Response[node.LDAPProviders], error)
}

// NewInternalServiceClient constructs a client for the infinimesh.node.InternalService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewInternalServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) InternalServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &internalServiceClient{
		getLDAPProviders: connect.NewClient[node.EmptyMessage, node.LDAPProviders](
			httpClient,
			baseURL+InternalServiceGetLDAPProvidersProcedure,
			connect.WithSchema(internalServiceGetLDAPProvidersMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
	}
}

// internalServiceClient implements InternalServiceClient.
type internalServiceClient struct {
	getLDAPProviders *connect.Client[node.EmptyMessage, node.LDAPProviders]
}

// GetLDAPProviders calls infinimesh.node.InternalService.GetLDAPProviders.
func (c *internalServiceClient) GetLDAPProviders(ctx context.Context, req *connect.Request[node.EmptyMessage]) (*connect.Response[node.LDAPProviders], error) {
	return c.getLDAPProviders.CallUnary(ctx, req)
}

// InternalServiceHandler is an implementation of the infinimesh.node.InternalService service.
type InternalServiceHandler interface {
	GetLDAPProviders(context.Context, *connect.Request[node.EmptyMessage]) (*connect.Response[node.LDAPProviders], error)
}

// NewInternalServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewInternalServiceHandler(svc InternalServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	internalServiceGetLDAPProvidersHandler := connect.NewUnaryHandler(
		InternalServiceGetLDAPProvidersProcedure,
		svc.GetLDAPProviders,
		connect.WithSchema(internalServiceGetLDAPProvidersMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	return "/infinimesh.node.InternalService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case InternalServiceGetLDAPProvidersProcedure:
			internalServiceGetLDAPProvidersHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedInternalServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedInternalServiceHandler struct{}

func (UnimplementedInternalServiceHandler) GetLDAPProviders(context.Context, *connect.Request[node.EmptyMessage]) (*connect.Response[node.LDAPProviders], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("infinimesh.node.InternalService.GetLDAPProviders is not implemented"))
}
