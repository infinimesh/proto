// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: timeseries/timeseries.proto

package timeseries

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on DataPoint with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DataPoint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataPoint with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DataPointMultiError, or nil
// if none found.
func (m *DataPoint) ValidateAll() error {
	return m.validate(true)
}

func (m *DataPoint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ts

	// no validation rules for Value

	if len(errors) > 0 {
		return DataPointMultiError(errors)
	}

	return nil
}

// DataPointMultiError is an error wrapping multiple validation errors returned
// by DataPoint.ValidateAll() if the designated constraints aren't met.
type DataPointMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataPointMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataPointMultiError) AllErrors() []error { return m }

// DataPointValidationError is the validation error returned by
// DataPoint.Validate if the designated constraints aren't met.
type DataPointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataPointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataPointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataPointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataPointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataPointValidationError) ErrorName() string { return "DataPointValidationError" }

// Error satisfies the builtin error interface
func (e DataPointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataPoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataPointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataPointValidationError{}

// Validate checks the field values on WriteRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WriteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WriteRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WriteRequestMultiError, or
// nil if none found.
func (m *WriteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WriteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Device

	// no validation rules for Metric

	if all {
		switch v := interface{}(m.GetDataPoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WriteRequestValidationError{
					field:  "DataPoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WriteRequestValidationError{
					field:  "DataPoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDataPoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WriteRequestValidationError{
				field:  "DataPoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DuplicatePolicy

	if len(errors) > 0 {
		return WriteRequestMultiError(errors)
	}

	return nil
}

// WriteRequestMultiError is an error wrapping multiple validation errors
// returned by WriteRequest.ValidateAll() if the designated constraints aren't met.
type WriteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WriteRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WriteRequestMultiError) AllErrors() []error { return m }

// WriteRequestValidationError is the validation error returned by
// WriteRequest.Validate if the designated constraints aren't met.
type WriteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WriteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WriteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WriteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WriteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WriteRequestValidationError) ErrorName() string { return "WriteRequestValidationError" }

// Error satisfies the builtin error interface
func (e WriteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWriteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WriteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WriteRequestValidationError{}

// Validate checks the field values on WriteResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WriteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WriteResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WriteResponseMultiError, or
// nil if none found.
func (m *WriteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *WriteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	// no validation rules for Ts

	if len(errors) > 0 {
		return WriteResponseMultiError(errors)
	}

	return nil
}

// WriteResponseMultiError is an error wrapping multiple validation errors
// returned by WriteResponse.ValidateAll() if the designated constraints
// aren't met.
type WriteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WriteResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WriteResponseMultiError) AllErrors() []error { return m }

// WriteResponseValidationError is the validation error returned by
// WriteResponse.Validate if the designated constraints aren't met.
type WriteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WriteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WriteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WriteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WriteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WriteResponseValidationError) ErrorName() string { return "WriteResponseValidationError" }

// Error satisfies the builtin error interface
func (e WriteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWriteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WriteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WriteResponseValidationError{}

// Validate checks the field values on WriteBulkRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WriteBulkRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WriteBulkRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WriteBulkRequestMultiError, or nil if none found.
func (m *WriteBulkRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WriteBulkRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Device

	// no validation rules for Metric

	for idx, item := range m.GetDataPoints() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WriteBulkRequestValidationError{
						field:  fmt.Sprintf("DataPoints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WriteBulkRequestValidationError{
						field:  fmt.Sprintf("DataPoints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WriteBulkRequestValidationError{
					field:  fmt.Sprintf("DataPoints[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for DuplicatePolicy

	if len(errors) > 0 {
		return WriteBulkRequestMultiError(errors)
	}

	return nil
}

// WriteBulkRequestMultiError is an error wrapping multiple validation errors
// returned by WriteBulkRequest.ValidateAll() if the designated constraints
// aren't met.
type WriteBulkRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WriteBulkRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WriteBulkRequestMultiError) AllErrors() []error { return m }

// WriteBulkRequestValidationError is the validation error returned by
// WriteBulkRequest.Validate if the designated constraints aren't met.
type WriteBulkRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WriteBulkRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WriteBulkRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WriteBulkRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WriteBulkRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WriteBulkRequestValidationError) ErrorName() string { return "WriteBulkRequestValidationError" }

// Error satisfies the builtin error interface
func (e WriteBulkRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWriteBulkRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WriteBulkRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WriteBulkRequestValidationError{}

// Validate checks the field values on WriteBulkResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WriteBulkResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WriteBulkResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WriteBulkResponseMultiError, or nil if none found.
func (m *WriteBulkResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *WriteBulkResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	if len(errors) > 0 {
		return WriteBulkResponseMultiError(errors)
	}

	return nil
}

// WriteBulkResponseMultiError is an error wrapping multiple validation errors
// returned by WriteBulkResponse.ValidateAll() if the designated constraints
// aren't met.
type WriteBulkResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WriteBulkResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WriteBulkResponseMultiError) AllErrors() []error { return m }

// WriteBulkResponseValidationError is the validation error returned by
// WriteBulkResponse.Validate if the designated constraints aren't met.
type WriteBulkResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WriteBulkResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WriteBulkResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WriteBulkResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WriteBulkResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WriteBulkResponseValidationError) ErrorName() string {
	return "WriteBulkResponseValidationError"
}

// Error satisfies the builtin error interface
func (e WriteBulkResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWriteBulkResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WriteBulkResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WriteBulkResponseValidationError{}

// Validate checks the field values on Aggregation with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Aggregation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Aggregation with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AggregationMultiError, or
// nil if none found.
func (m *Aggregation) ValidateAll() error {
	return m.validate(true)
}

func (m *Aggregation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	// no validation rules for AggregationType

	if len(errors) > 0 {
		return AggregationMultiError(errors)
	}

	return nil
}

// AggregationMultiError is an error wrapping multiple validation errors
// returned by Aggregation.ValidateAll() if the designated constraints aren't met.
type AggregationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AggregationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AggregationMultiError) AllErrors() []error { return m }

// AggregationValidationError is the validation error returned by
// Aggregation.Validate if the designated constraints aren't met.
type AggregationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AggregationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AggregationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AggregationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AggregationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AggregationValidationError) ErrorName() string { return "AggregationValidationError" }

// Error satisfies the builtin error interface
func (e AggregationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAggregation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AggregationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AggregationValidationError{}

// Validate checks the field values on ReadRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReadRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReadRequestMultiError, or
// nil if none found.
func (m *ReadRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Device

	// no validation rules for From

	if m.To != nil {
		// no validation rules for To
	}

	if m.Aggregation != nil {

		if all {
			switch v := interface{}(m.GetAggregation()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReadRequestValidationError{
						field:  "Aggregation",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReadRequestValidationError{
						field:  "Aggregation",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAggregation()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReadRequestValidationError{
					field:  "Aggregation",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReadRequestMultiError(errors)
	}

	return nil
}

// ReadRequestMultiError is an error wrapping multiple validation errors
// returned by ReadRequest.ValidateAll() if the designated constraints aren't met.
type ReadRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadRequestMultiError) AllErrors() []error { return m }

// ReadRequestValidationError is the validation error returned by
// ReadRequest.Validate if the designated constraints aren't met.
type ReadRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadRequestValidationError) ErrorName() string { return "ReadRequestValidationError" }

// Error satisfies the builtin error interface
func (e ReadRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadRequestValidationError{}

// Validate checks the field values on MetricInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MetricInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MetricInfoMultiError, or
// nil if none found.
func (m *MetricInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Metric

	for idx, item := range m.GetDataPoints() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricInfoValidationError{
						field:  fmt.Sprintf("DataPoints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricInfoValidationError{
						field:  fmt.Sprintf("DataPoints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricInfoValidationError{
					field:  fmt.Sprintf("DataPoints[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MetricInfoMultiError(errors)
	}

	return nil
}

// MetricInfoMultiError is an error wrapping multiple validation errors
// returned by MetricInfo.ValidateAll() if the designated constraints aren't met.
type MetricInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricInfoMultiError) AllErrors() []error { return m }

// MetricInfoValidationError is the validation error returned by
// MetricInfo.Validate if the designated constraints aren't met.
type MetricInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricInfoValidationError) ErrorName() string { return "MetricInfoValidationError" }

// Error satisfies the builtin error interface
func (e MetricInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricInfoValidationError{}

// Validate checks the field values on ReadResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReadResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReadResponseMultiError, or
// nil if none found.
func (m *ReadResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMetricsInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReadResponseValidationError{
						field:  fmt.Sprintf("MetricsInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReadResponseValidationError{
						field:  fmt.Sprintf("MetricsInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReadResponseValidationError{
					field:  fmt.Sprintf("MetricsInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReadResponseMultiError(errors)
	}

	return nil
}

// ReadResponseMultiError is an error wrapping multiple validation errors
// returned by ReadResponse.ValidateAll() if the designated constraints aren't met.
type ReadResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadResponseMultiError) AllErrors() []error { return m }

// ReadResponseValidationError is the validation error returned by
// ReadResponse.Validate if the designated constraints aren't met.
type ReadResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadResponseValidationError) ErrorName() string { return "ReadResponseValidationError" }

// Error satisfies the builtin error interface
func (e ReadResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadResponseValidationError{}

// Validate checks the field values on Metric with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Metric) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Metric with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MetricMultiError, or nil if none found.
func (m *Metric) ValidateAll() error {
	return m.validate(true)
}

func (m *Metric) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for DataPoints

	if all {
		switch v := interface{}(m.GetEarliest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricValidationError{
					field:  "Earliest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricValidationError{
					field:  "Earliest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEarliest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricValidationError{
				field:  "Earliest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLatest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricValidationError{
					field:  "Latest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricValidationError{
					field:  "Latest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLatest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricValidationError{
				field:  "Latest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MetricMultiError(errors)
	}

	return nil
}

// MetricMultiError is an error wrapping multiple validation errors returned by
// Metric.ValidateAll() if the designated constraints aren't met.
type MetricMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricMultiError) AllErrors() []error { return m }

// MetricValidationError is the validation error returned by Metric.Validate if
// the designated constraints aren't met.
type MetricValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricValidationError) ErrorName() string { return "MetricValidationError" }

// Error satisfies the builtin error interface
func (e MetricValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetric.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricValidationError{}

// Validate checks the field values on DeviceMetric with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeviceMetric) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeviceMetric with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeviceMetricMultiError, or
// nil if none found.
func (m *DeviceMetric) ValidateAll() error {
	return m.validate(true)
}

func (m *DeviceMetric) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Device

	for idx, item := range m.GetMetrics() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeviceMetricValidationError{
						field:  fmt.Sprintf("Metrics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeviceMetricValidationError{
						field:  fmt.Sprintf("Metrics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeviceMetricValidationError{
					field:  fmt.Sprintf("Metrics[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeviceMetricMultiError(errors)
	}

	return nil
}

// DeviceMetricMultiError is an error wrapping multiple validation errors
// returned by DeviceMetric.ValidateAll() if the designated constraints aren't met.
type DeviceMetricMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeviceMetricMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeviceMetricMultiError) AllErrors() []error { return m }

// DeviceMetricValidationError is the validation error returned by
// DeviceMetric.Validate if the designated constraints aren't met.
type DeviceMetricValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeviceMetricValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeviceMetricValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeviceMetricValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeviceMetricValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeviceMetricValidationError) ErrorName() string { return "DeviceMetricValidationError" }

// Error satisfies the builtin error interface
func (e DeviceMetricValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeviceMetric.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeviceMetricValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeviceMetricValidationError{}

// Validate checks the field values on StatRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StatRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StatRequestMultiError, or
// nil if none found.
func (m *StatRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StatRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Namespace != nil {
		// no validation rules for Namespace
	}

	if m.Device != nil {
		// no validation rules for Device
	}

	if len(errors) > 0 {
		return StatRequestMultiError(errors)
	}

	return nil
}

// StatRequestMultiError is an error wrapping multiple validation errors
// returned by StatRequest.ValidateAll() if the designated constraints aren't met.
type StatRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatRequestMultiError) AllErrors() []error { return m }

// StatRequestValidationError is the validation error returned by
// StatRequest.Validate if the designated constraints aren't met.
type StatRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatRequestValidationError) ErrorName() string { return "StatRequestValidationError" }

// Error satisfies the builtin error interface
func (e StatRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatRequestValidationError{}

// Validate checks the field values on StatResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StatResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StatResponseMultiError, or
// nil if none found.
func (m *StatResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StatResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDeviceMetrics() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StatResponseValidationError{
						field:  fmt.Sprintf("DeviceMetrics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StatResponseValidationError{
						field:  fmt.Sprintf("DeviceMetrics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StatResponseValidationError{
					field:  fmt.Sprintf("DeviceMetrics[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return StatResponseMultiError(errors)
	}

	return nil
}

// StatResponseMultiError is an error wrapping multiple validation errors
// returned by StatResponse.ValidateAll() if the designated constraints aren't met.
type StatResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatResponseMultiError) AllErrors() []error { return m }

// StatResponseValidationError is the validation error returned by
// StatResponse.Validate if the designated constraints aren't met.
type StatResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatResponseValidationError) ErrorName() string { return "StatResponseValidationError" }

// Error satisfies the builtin error interface
func (e StatResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatResponseValidationError{}

// Validate checks the field values on FlushRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FlushRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FlushRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FlushRequestMultiError, or
// nil if none found.
func (m *FlushRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FlushRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Namespace != nil {
		// no validation rules for Namespace
	}

	if m.Device != nil {
		// no validation rules for Device
	}

	if len(errors) > 0 {
		return FlushRequestMultiError(errors)
	}

	return nil
}

// FlushRequestMultiError is an error wrapping multiple validation errors
// returned by FlushRequest.ValidateAll() if the designated constraints aren't met.
type FlushRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlushRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlushRequestMultiError) AllErrors() []error { return m }

// FlushRequestValidationError is the validation error returned by
// FlushRequest.Validate if the designated constraints aren't met.
type FlushRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlushRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlushRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlushRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlushRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlushRequestValidationError) ErrorName() string { return "FlushRequestValidationError" }

// Error satisfies the builtin error interface
func (e FlushRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlushRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlushRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlushRequestValidationError{}

// Validate checks the field values on FlushResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FlushResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FlushResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FlushResponseMultiError, or
// nil if none found.
func (m *FlushResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FlushResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	if len(errors) > 0 {
		return FlushResponseMultiError(errors)
	}

	return nil
}

// FlushResponseMultiError is an error wrapping multiple validation errors
// returned by FlushResponse.ValidateAll() if the designated constraints
// aren't met.
type FlushResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlushResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlushResponseMultiError) AllErrors() []error { return m }

// FlushResponseValidationError is the validation error returned by
// FlushResponse.Validate if the designated constraints aren't met.
type FlushResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlushResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlushResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlushResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlushResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlushResponseValidationError) ErrorName() string { return "FlushResponseValidationError" }

// Error satisfies the builtin error interface
func (e FlushResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlushResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlushResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlushResponseValidationError{}
